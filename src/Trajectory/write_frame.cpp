#include <cstring>
#include "copyright.h"
#include "Constants/symbol_values.h"
#include "Parsing/ascii_numbers.h"
#include "Parsing/polynumeric.h"
#include "write_frame.h"

namespace stormm {
namespace trajectory {

using parse::NumberFormat;
using parse::PolyNumeric;

//-------------------------------------------------------------------------------------------------
PrintSituation adjustTrajectoryOpeningProtocol(const PrintSituation expectation,
                                               const CoordinateFileKind output_kind,
                                               const char* caller, const char* method) {
  switch (output_kind) {
  case CoordinateFileKind::AMBER_CRD:
  case CoordinateFileKind::AMBER_NETCDF:
    return (expectation == PrintSituation::UNKNOWN) ? PrintSituation::APPEND : expectation;
  case CoordinateFileKind::AMBER_INPCRD:
  case CoordinateFileKind::AMBER_ASCII_RST:
  case CoordinateFileKind::AMBER_NETCDF_RST:
    switch (expectation) {
    case PrintSituation::OPEN_NEW:
    case PrintSituation::OVERWRITE:
      return expectation;
    case PrintSituation::APPEND:
      rtErr("Input coordinate and restart files cannot be appended.  They can only be written if "
            "no file is present, overwritten if permitted by the user / developer, or generate an "
            "error if the file exists and overwriting is not enabled.", caller, method);
    case PrintSituation::UNKNOWN:
      return PrintSituation::OPEN_NEW;
    }
    break;
  case CoordinateFileKind::UNKNOWN:
    rtErr("Printing request for unknown file type.", caller, method);
  }
  __builtin_unreachable();
}

//-------------------------------------------------------------------------------------------------
void initializeTrajectory(std::ofstream *foutp, const CoordinateFileKind output_kind,
                          const int atom_count, const double current_time) {
  char buffer[128];
  sprintf(buffer, "Generated by STORMM\n");
  switch (output_kind) {
  case CoordinateFileKind::AMBER_CRD:
    foutp->write(buffer, strlen(buffer));
    break;
  case CoordinateFileKind::AMBER_INPCRD:
    sprintf(&buffer[strlen(buffer)], "%8d\n", atom_count);
    foutp->write(buffer, strlen(buffer));
    break;
  case CoordinateFileKind::AMBER_ASCII_RST:
    sprintf(&buffer[strlen(buffer)], "%8d %15.7e\n", atom_count, current_time);
    foutp->write(buffer, strlen(buffer));
    break;
  case CoordinateFileKind::AMBER_NETCDF:
  case CoordinateFileKind::AMBER_NETCDF_RST:
  case CoordinateFileKind::UNKNOWN:
    break;
  }
}
  
//-------------------------------------------------------------------------------------------------
void writeFrame(std::ofstream *foutp, const std::string &filename, const CoordinateFileKind kind,
                int natom, const double* x_crd, const double* y_crd, const double* z_crd,
                const double* x_vel, const double* y_vel, const double* z_vel,
                const UnitCellType unit_cell, const double* box_dimensions) {

  // Declare arrays that will be filled out later, as necessary
  std::vector<PolyNumeric> pn_allcrd;
  std::vector<PolyNumeric> pn_allvel;
  
  // Lay out the appropriate coordinates array: PolyNumeric for ASCII text speed printing,
  // double-precision real vector for NetCDF and other formats
  switch (kind) {
  case CoordinateFileKind::AMBER_CRD:
  case CoordinateFileKind::AMBER_INPCRD:
  case CoordinateFileKind::AMBER_ASCII_RST:
    pn_allcrd.resize(3 * natom);
    for (int i = 0; i < natom; i++) {
      pn_allcrd[3*i    ].d = x_crd[i];
      pn_allcrd[3*i + 1].d = y_crd[i];
      pn_allcrd[3*i + 2].d = z_crd[i];
    }
    break;
  case CoordinateFileKind::AMBER_NETCDF:
  case CoordinateFileKind::AMBER_NETCDF_RST:
    break;
  case CoordinateFileKind::UNKNOWN:
    rtErr("The coordinate file type of " + filename + " could not be understood.", "writeFrame");
  }
  switch (kind) {
  case CoordinateFileKind::AMBER_CRD:
  case CoordinateFileKind::AMBER_INPCRD:
  case CoordinateFileKind::AMBER_NETCDF:
  case CoordinateFileKind::AMBER_NETCDF_RST:
    break;
  case CoordinateFileKind::AMBER_ASCII_RST:
    pn_allvel.resize(3 * natom);
    for (int i = 0; i < natom; i++) {
      pn_allvel[3*i    ].d = x_vel[i];
      pn_allvel[3*i + 1].d = y_vel[i];
      pn_allvel[3*i + 2].d = z_vel[i];
    }
    break;
  case CoordinateFileKind::UNKNOWN:

    // The case of an unknown format is handled in the switch above
    break;
  }
  switch (kind) {
  case CoordinateFileKind::AMBER_CRD:
    printNumberSeries(foutp, pn_allcrd, 10, 8, 3, NumberFormat::STANDARD_REAL, "writeFrame",
                      "Write a frame to an Amber-format .crd trajectory file, " + filename +
                      ".");
    break;
  case CoordinateFileKind::AMBER_INPCRD:
    printNumberSeries(foutp, pn_allcrd, 6, 12, 7, NumberFormat::STANDARD_REAL, "writeFrame",
                      "Write a frame to an Amber-format input coordinates file, " + filename +
                      ".");
    break;
  case CoordinateFileKind::AMBER_ASCII_RST:
    printNumberSeries(foutp, pn_allcrd, 6, 12, 7, NumberFormat::STANDARD_REAL, "writeFrame",
                      "Write a frame to an Amber-format input coordinates file, " + filename +
                      ".");
    printNumberSeries(foutp, pn_allvel, 6, 12, 7, NumberFormat::STANDARD_REAL, "writeFrame",
                      "Write a frame to an Amber-format input coordinates file, " + filename +
                      ".");
    break;
  case CoordinateFileKind::AMBER_NETCDF:
  case CoordinateFileKind::AMBER_NETCDF_RST:
  case CoordinateFileKind::UNKNOWN:
    break;
  }

  // Print the unit cell information  
  switch (unit_cell) {
  case UnitCellType::NONE:
    break;
  case UnitCellType::ORTHORHOMBIC:
  case UnitCellType::TRICLINIC:
    switch (kind) {
    case CoordinateFileKind::AMBER_CRD:
      {
        std::vector<PolyNumeric> pn_boxlen(3);
        for (int i = 0; i < 3; i++) {
          pn_boxlen[i].d = box_dimensions[i];
        }        
        printNumberSeries(foutp, pn_boxlen, 3, 8, 3, NumberFormat::STANDARD_REAL, "writeFrame",
                          "Write box dimensions to an Amber-format coordinate trajectory, " +
                          filename + ".");
      }
      break;
    case CoordinateFileKind::AMBER_INPCRD:
    case CoordinateFileKind::AMBER_ASCII_RST:
      {
        std::vector<PolyNumeric> pn_boxdim(6);
        for (int i = 0; i < 3; i++) {
          pn_boxdim[i].d = box_dimensions[i];
        }
        for (int i = 3; i < 6; i++) {
          pn_boxdim[i].d = box_dimensions[i] * 180.0 / symbols::pi;
        }
        printNumberSeries(foutp, pn_boxdim, 6, 12, 7, NumberFormat::STANDARD_REAL, "writeFrame",
                          "Write box dimensions to an Amber-format input coordinates file, " +
                          filename + ".");
      }
      break;
    case CoordinateFileKind::AMBER_NETCDF:
    case CoordinateFileKind::AMBER_NETCDF_RST:
    case CoordinateFileKind::UNKNOWN:
      break;
    }
    break;
  }
}

//-------------------------------------------------------------------------------------------------
void writeFrame(std::ofstream *foutp, const std::string &filename, const CoordinateFileKind kind,
                const std::vector<double> &x_crd, const std::vector<double> &y_crd,
                const std::vector<double> &z_crd, const std::vector<double> &x_vel,
                const std::vector<double> &y_vel, const std::vector<double> &z_vel,
                const UnitCellType unit_cell, const std::vector<double> &box_dimensions) {

  // Check that all arrays are of the same size
  if (x_crd.size() != y_crd.size() || x_crd.size() != z_crd.size()) {
    rtErr("Coordinates cannot be written for x, y, and z vectors of different lengths (" +
          std::to_string(x_crd.size()) + ", " + std::to_string(y_crd.size()) + ", " + 
          std::to_string(x_crd.size()) + ").", "writeAmberCrd");
  }

  // Check that all required data is present

  // Check that the box dimensions array is of the correct size
  if (box_dimensions.size() != 6) {
    rtErr("Invalid vector for box dimensions (" + std::to_string(box_dimensions.size()) + ").",
          "writeAmberCrd");
  }
  writeFrame(foutp, filename, kind, x_crd.size(), x_crd.data(), y_crd.data(), z_crd.data(),
             x_vel.data(), y_vel.data(), z_vel.data(), unit_cell, box_dimensions.data());
}
  
} // namespace trajectory
} // namespace stormm
