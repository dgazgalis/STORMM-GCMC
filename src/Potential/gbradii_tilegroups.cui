// -*-c++-*-
#include "copyright.h"

#define EXCL_GMEM_OFFSET  (blockIdx.x * gmem_r.max_atoms)

/// \brief Compute the Generalized Born radii for all particles in all systems.
///
/// \param poly_nbk  Condensed non-bonded parameter tables and atomic properties for all systems
/// \param ngb_kit   Neck Generalized Born parameters
/// \param ctrl      Molecular mechanics control data
/// \param poly_psw  Coordinates and forces for all particles
/// \param gmem_r    Workspaces for each thread block
__global__ void __launch_bounds__(small_block_size, GBRADII_KERNEL_BLOCKS_MULTIPLIER)
KERNEL_NAME(const SyNonbondedKit<TCALC, TCALC2> poly_nbk, MMControlKit<TCALC> ctrl,
            PsSynthesisWriter poly_psw, CacheResourceKit<TCALC> gmem_r, ISWorkspaceKit isw) {

  // Coordinate and properties of particles are copied into special, L1-cached arrays of GMEM used
  // exclusively by this block.
  __shared__ TCALC sh_tile_xcog[small_block_max_imports];
  __shared__ TCALC sh_tile_ycog[small_block_max_imports];
  __shared__ TCALC sh_tile_zcog[small_block_max_imports];
  __shared__ TCALC sh_tile_tpts[small_block_max_imports];
  __shared__ TCALC sh_pbradii[small_block_max_imports];
  __shared__ TCALC sh_screen[small_block_max_imports];
#ifdef TCALC_IS_SINGLE
  __shared__ int sh_psi[small_block_max_imports];
#else
  __shared__ llint sh_psi[small_block_max_imports];
#endif
  __shared__ int sh_psi_overflow[small_block_max_imports];
  __shared__ int sh_neck_idx[small_block_max_imports];
  __shared__ int nbwu_map[tile_groups_wu_abstract_length];
  __shared__ int gbrwu_idx;

  // Read the non-bonded work unit abstracts
  if (threadIdx.x == 0) {
    gbrwu_idx = blockIdx.x;
  }
  __syncthreads();
  while (gbrwu_idx < poly_nbk.nnbwu) {
    if (threadIdx.x < tile_groups_wu_abstract_length) {
      nbwu_map[threadIdx.x] =__ldcv(&poly_nbk.nbwu_abstracts[(gbrwu_idx *
                                                              tile_groups_wu_abstract_length) +
                                                             threadIdx.x]);
    }    
    __syncthreads();

    // Import atomic coordinates and properties.  Each warp will handle importing one of the
    // Cartesian coordinates or properties of as many tile sides as it can handle, in order to
    // get the most threads reaching out to global memory.
    const int tile_sides_per_warp = (warp_size_int / tile_length);
    const int warp_idx = (threadIdx.x >> warp_bits);
    const int warp_lane_idx = (threadIdx.x & warp_bits_mask_int);
    const int tile_side_offset = warp_lane_idx / tile_length;
    const int import_count = nbwu_map[0];
    int pos = (tile_sides_per_warp * warp_idx) + tile_side_offset;
#ifdef TCALC_IS_SINGLE
    pos = loadTileCoordinates(pos, import_count, 0, nbwu_map, poly_psw.xcrd,
                              &gmem_r.xcrd[EXCL_GMEM_OFFSET], sh_tile_xcog, poly_psw.gpos_scale_f);
    pos = loadTileCoordinates(pos, import_count, 1, nbwu_map, poly_psw.ycrd,
                              &gmem_r.ycrd[EXCL_GMEM_OFFSET], sh_tile_ycog, poly_psw.gpos_scale_f);
    pos = loadTileCoordinates(pos, import_count, 2, nbwu_map, poly_psw.zcrd,
                              &gmem_r.zcrd[EXCL_GMEM_OFFSET], sh_tile_zcog, poly_psw.gpos_scale_f);
#else
    pos = loadTileCoordinates(pos, import_count, 0, nbwu_map, poly_psw.xcrd,
                              &gmem_r.xcrd[EXCL_GMEM_OFFSET], poly_psw.xcrd_ovrf,
                              &gmem_r.xcrd_ovrf[EXCL_GMEM_OFFSET], sh_tile_xcog,
                              poly_psw.gpos_scale);
    pos = loadTileCoordinates(pos, import_count, 1, nbwu_map, poly_psw.ycrd,
                              &gmem_r.ycrd[EXCL_GMEM_OFFSET], poly_psw.ycrd_ovrf,
                              &gmem_r.ycrd_ovrf[EXCL_GMEM_OFFSET], sh_tile_ycog,
                              poly_psw.gpos_scale);
    pos = loadTileCoordinates(pos, import_count, 2, nbwu_map, poly_psw.zcrd,
                              &gmem_r.zcrd[EXCL_GMEM_OFFSET], poly_psw.zcrd_ovrf,
                              &gmem_r.zcrd_ovrf[EXCL_GMEM_OFFSET], sh_tile_zcog,
                              poly_psw.gpos_scale);
#endif
    pos = loadTileProperty(pos, import_count, 3, nbwu_map, poly_nbk.pb_radii, -poly_nbk.gb_offset,
                           sh_pbradii);
    pos = loadTileProperty(pos, import_count, 4, nbwu_map, poly_nbk.gb_screen, sh_screen);
    const int padded_import_count = devcRoundUp(import_count, tile_sides_per_warp);
    const int warps_per_block = blockDim.x >> warp_bits;
    const int tile_lane_idx = (threadIdx.x & tile_length_bits_mask);
    while (pos < 6 * padded_import_count) {
      const int rel_pos = pos - (5 * padded_import_count);
      if (rel_pos < import_count) {
        const size_t write_idx = (rel_pos * tile_length) + tile_lane_idx;
#ifdef TCALC_IS_SINGLE
        sh_psi[write_idx] = 0;
#else
        sh_psi[write_idx] = 0LL;
#endif
        sh_psi_overflow[write_idx] = 0;
      }
      pos += tile_sides_per_warp * warps_per_block;
    }
    if (poly_nbk.igb == ImplicitSolventModel::NECK_GB ||
        poly_nbk.igb == ImplicitSolventModel::NECK_GB_II) {
      pos = loadTileProperty(pos, import_count, 5, nbwu_map, poly_nbk.neck_gb_idx, sh_neck_idx);
    }
    __syncthreads();

    // Loop over tile instructions
    pos = nbwu_map[small_block_max_imports + 6] + warp_idx;
    while (pos < nbwu_map[small_block_max_imports + 7]) {

      // Handle one tile per warp.  This works perfectly when the tile width is half the warp
      // width, but for commodity AMD and Intel architectures these bounds will need alterations.
      uint2 tinsr = poly_nbk.nbwu_insr[pos];
      const int local_absc_start = (tinsr.x & 0xffff);
      const int local_ordi_start = ((tinsr.x >> 16) & 0xffff);
      const int absc_import_idx = local_absc_start >> tile_length_bits;
      const int ordi_import_idx = local_ordi_start >> tile_length_bits;

      // Obtain the tile atoms' Cartesian X, Y, and Z centering for best results.
      const TCALC inv_tile_pts = (TCALC)(1.0) /
                                 (sh_tile_tpts[absc_import_idx] + sh_tile_tpts[ordi_import_idx]);
      const TCALC tx_cog = (sh_tile_xcog[absc_import_idx] + sh_tile_xcog[ordi_import_idx]) *
                           inv_tile_pts;
      const TCALC ty_cog = (sh_tile_ycog[absc_import_idx] + sh_tile_ycog[ordi_import_idx]) *
                           inv_tile_pts;
      const TCALC tz_cog = (sh_tile_zcog[absc_import_idx] + sh_tile_zcog[ordi_import_idx]) *
                           inv_tile_pts;
      int read_idx  = ((warp_lane_idx <  tile_length) * local_absc_start) +
                      ((warp_lane_idx >= tile_length) * local_ordi_start) + tile_lane_idx +
                      EXCL_GMEM_OFFSET;
#ifdef TCALC_IS_SINGLE
      const llint x_center = LLCONV_FUNC(tx_cog);
      const llint y_center = LLCONV_FUNC(ty_cog);
      const llint z_center = LLCONV_FUNC(tz_cog);
      const TCALC t_xcrd   = (TCALC)(gmem_r.xcrd[read_idx] - x_center) * poly_psw.inv_gpos_scale;
      const TCALC t_ycrd   = (TCALC)(gmem_r.ycrd[read_idx] - y_center) * poly_psw.inv_gpos_scale;
      const TCALC t_zcrd   = (TCALC)(gmem_r.zcrd[read_idx] - z_center) * poly_psw.inv_gpos_scale;
#else
      // Convert the negative values of the center-of-geometry coordinates so that the result
      // can feed into splitFPSum() (which adds A + B).
      const int95_t x_center = doubleToInt95(-tx_cog);
      const int95_t y_center = doubleToInt95(-ty_cog);
      const int95_t z_center = doubleToInt95(-tz_cog);
      const int95_t x_atom   = { gmem_r.xcrd[read_idx], gmem_r.xcrd_ovrf[read_idx] };
      const int95_t y_atom   = { gmem_r.ycrd[read_idx], gmem_r.ycrd_ovrf[read_idx] };
      const int95_t z_atom   = { gmem_r.zcrd[read_idx], gmem_r.zcrd_ovrf[read_idx] };
      const int95_t x95_tmp  = splitFPSum(x_atom, x_center);
      const int95_t y95_tmp  = splitFPSum(y_atom, y_center);
      const int95_t z95_tmp  = splitFPSum(z_atom, z_center);
      const TCALC t_xcrd = splitFPToReal(x95_tmp) * poly_psw.inv_gpos_scale;
      const TCALC t_ycrd = splitFPToReal(y95_tmp) * poly_psw.inv_gpos_scale;
      const TCALC t_zcrd = splitFPToReal(z95_tmp) * poly_psw.inv_gpos_scale;
#endif
      const TCALC t_radius = sh_pbradii[read_idx - EXCL_GMEM_OFFSET];
      const TCALC t_screen = sh_screen[read_idx - EXCL_GMEM_OFFSET];
      for (int i = 0; i < half_tile_length; i++) {
        int crd_src_lane = ((warp_lane_idx <  tile_length) * (warp_lane_idx + tile_length - i)) +
                           ((warp_lane_idx >= tile_length) *
                           (warp_lane_idx - three_halves_tile_length + i));
        crd_src_lane += tile_length *
                        ((crd_src_lane < tile_length && warp_lane_idx  < tile_length) +
                         (crd_src_lane <           0 && warp_lane_idx >= tile_length));
        const TCALC o_xcrd  = SHFL(t_xcrd,  crd_src_lane);
        const TCALC o_ycrd  = SHFL(t_ycrd,  crd_src_lane);
        const TCALC o_zcrd  = SHFL(t_zcrd,  crd_src_lane);
      }
    }

    // Increment the work unit counter
    __syncthreads();
    if (threadIdx.x == 0) {
      const size_t prog_counter_idx = (ctrl.step & twice_warp_bits_mask_int);
      gbrwu_idx = atomicAdd(&ctrl.gbrwu_progress[prog_counter_idx], 1);
    }
    __syncthreads();    
  }
}
