// -*-c++-*-
#include "copyright.h"

#define EXCL_GMEM_OFFSET  (blockIdx.x * gmem_r.max_atoms)

// The "standalone" pre-processor directive constructs a separate kernel to implement the virtual
// site placement.  Without the standalone directive, the code still assumes the availability of
// critical variables, including a phase space synthesis writeable abstract named poly_psw, a
// const valence kit (which includes valence work units and imported atom maps) named poly_vk,
// and a cache resource kit named gmem_r.
#ifdef VSITE_STANDALONE
__global__ void	__launch_bounds__(small_block_size, 4)
KERNEL_NAME(PsSynthesisWriter poly_psw, const SyValenceKit<TCALC> poly_vk,
            const SyAtomUpdateKit<TCALC2, TCALC4> poly_auk, CacheResourceKit<TCALC> gmem_r) {
  __shared__ int2 vwu_map[vwu_abstract_length];
  __shared__ int vwu_task_count[vwu_abstract_length];
  __shared__ int vwu_padded_task_count[vwu_abstract_length];
  __shared__ int vwu_idx;

  if (threadIdx.x == 0) {
    vwu_idx = blockIdx.x;
  }
  __syncthreads();
  while (vwu_idx < poly_vk.nvwu) {

    // The instruction set map is read and stored in __shared__ for convenience, and to ensure
    // that it never leaves cache.  The instructions themselves are "streamed," which for purposes
    // of this documentation means read from global, used once, and not cached.  Each block must be
    // at least vwu_abstract_length + warp_size_int in size.  Currently, that is 96 on NVIDIA GPUs
    // 128 on commodity AMD GPUs, and only 64 on Intel GPUs.
    if (threadIdx.x < vwu_abstract_length) {
      vwu_map[threadIdx.x] = __ldcv(&poly_vk.vwu_abstracts[(vwu_idx * vwu_abstract_length) +
                                                           threadIdx.x]);
      vwu_task_count[threadIdx.x] = vwu_map[threadIdx.x].y - vwu_map[threadIdx.x].x;
      vwu_padded_task_count[threadIdx.x] = devcRoundUp(vwu_task_count[threadIdx.x], warp_size_int);
    }
    __syncthreads();

    // Import atomic coordinates, properties, and (if appropriate) velocities.  This employs all
    // threads of the block, breaking up each set of information at the warp level.
    const int import_llim = vwu_map[(size_t)(VwuAbstractMap::IMPORT)].x;
    const int import_hlim = vwu_map[(size_t)(VwuAbstractMap::IMPORT)].y;
    const int import_count  = import_hlim - import_llim;
    const int import_stride = devcRoundUp(import_hlim - import_llim, warp_size_int);
    int pos = threadIdx.x;
    while (pos < import_stride) {
      if (pos < import_count) {
        const size_t read_idx  = __ldca(&poly_vk.vwu_imports[import_llim + pos]);
        const size_t write_idx = EXCL_GMEM_OFFSET + pos;
        __stwb(&gmem_r.xcrd[write_idx], __ldcs(&poly_psw.xcrd[read_idx]));
#  ifndef TCALC_IS_SINGLE
        __stwb(&gmem_r.xcrd_ovrf[write_idx], __ldcs(&poly_psw.xcrd_ovrf[read_idx]));
#  endif
      }
      pos += blockDim.x;
    }
    while (pos < 2 * import_stride) {
      const int rel_pos = pos - import_stride;
      if (rel_pos < import_count) {
        const size_t read_idx  = __ldca(&poly_vk.vwu_imports[import_llim + rel_pos]);
        const size_t write_idx = EXCL_GMEM_OFFSET + rel_pos;
        __stwb(&gmem_r.ycrd[write_idx], __ldcs(&poly_psw.ycrd[read_idx]));
#  ifndef TCALC_IS_SINGLE
        __stwb(&gmem_r.ycrd_ovrf[write_idx], __ldcs(&poly_psw.ycrd_ovrf[read_idx]));
#  endif
      }
      pos += blockDim.x;
    }
    while (pos < 3 * import_stride) {
      const int rel_pos = pos - (2 * import_stride);
      if (rel_pos < import_count) {
        const size_t read_idx  = __ldca(&poly_vk.vwu_imports[import_llim + rel_pos]);
        const size_t write_idx = EXCL_GMEM_OFFSET + rel_pos;
        __stwb(&gmem_r.zcrd[write_idx], __ldcs(&poly_psw.zcrd[read_idx]));
#  ifndef TCALC_IS_SINGLE
        __stwb(&gmem_r.zcrd_ovrf[write_idx], __ldcs(&poly_psw.zcrd_ovrf[read_idx]));
#  endif
      }
      pos += blockDim.x;
    }
    __syncthreads();
    int vterm_limit;
#endif

    // Similar to the process with valence interaction terms, loop over all virtual site frames.
    pos = threadIdx.x;
    vterm_limit = vwu_padded_task_count[(size_t)(VwuAbstractMap::VSITE)];
    while (pos < vterm_limit) {
      if (pos < vwu_task_count[(size_t)(VwuAbstractMap::VSITE)]) {

        // Obtain the instruction
        const int task_offset = vwu_map[(size_t)(VwuAbstractMap::VSITE)].x;
        const uint2 tinsr = __ldcs(&poly_auk.vste_insr[task_offset + pos]);
        const int vs_atom = (tinsr.x & 0x3ff) + EXCL_GMEM_OFFSET;
        const int parent_atom = ((tinsr.x >> 10) & 0x3ff) + EXCL_GMEM_OFFSET;
        const int frame2_atom = ((tinsr.x >> 20) & 0x3ff) + EXCL_GMEM_OFFSET;
        const int fr_param_idx = ((tinsr.y >> 20) & 0xfff);
        const TCALC4 fr_details = poly_auk.vs_params[fr_param_idx];
        const VirtualSiteKind kind = static_cast<VirtualSiteKind>(fr_details.w);
        
        // The parent (first) and second frame atoms' locations must be read for any frame
        const llint parent_x = __ldca(&gmem_r.xcrd[parent_atom]);
        const llint parent_y = __ldca(&gmem_r.ycrd[parent_atom]);
        const llint parent_z = __ldca(&gmem_r.zcrd[parent_atom]);
        const llint frame2_x = __ldca(&gmem_r.xcrd[frame2_atom]);
        const llint frame2_y = __ldca(&gmem_r.ycrd[frame2_atom]);
        const llint frame2_z = __ldca(&gmem_r.zcrd[frame2_atom]);
#ifndef TCALC_IS_SINGLE
        const int parent_x_ovrf =  __ldca(&gmem_r.xcrd_ovrf[parent_atom]);
        const int parent_y_ovrf =  __ldca(&gmem_r.ycrd_ovrf[parent_atom]);
        const int parent_z_ovrf =  __ldca(&gmem_r.zcrd_ovrf[parent_atom]);
        const int frame2_x_ovrf =  __ldca(&gmem_r.xcrd_ovrf[frame2_atom]);
        const int frame2_y_ovrf =  __ldca(&gmem_r.ycrd_ovrf[frame2_atom]);
        const int frame2_z_ovrf =  __ldca(&gmem_r.zcrd_ovrf[frame2_atom]);
#endif
        switch (kind) {
        case VirtualSiteKind::FLEX_2:
          {
            // Multiplying by the inverse position scaling constant, only to multiply each number
            // by the scaling constant, is unecessary and will not preserve any extra precision in
            // any of the virtual site placements.
#ifdef TCALC_IS_SINGLE
            const TCALC dx = (TCALC)(frame2_x - parent_x);
            const TCALC dy = (TCALC)(frame2_y - parent_y);
            const TCALC dz = (TCALC)(frame2_z - parent_z);
            const TCALC disp_mult = fr_details.x;
            __stwb(&gmem_r.xcrd[vs_atom], parent_x + LLCONV_FUNC(dx * disp_mult));
            __stwb(&gmem_r.ycrd[vs_atom], parent_y + LLCONV_FUNC(dy * disp_mult));
            __stwb(&gmem_r.zcrd[vs_atom], parent_z + LLCONV_FUNC(dz * disp_mult));
#else
            const TCALC dx = int95SumToDouble(frame2_x, frame2_x_ovrf, -parent_x, -parent_x_ovrf);
            const TCALC dy = int95SumToDouble(frame2_y, frame2_y_ovrf, -parent_y, -parent_y_ovrf);
            const TCALC dz = int95SumToDouble(frame2_z, frame2_z_ovrf, -parent_z, -parent_z_ovrf);
            const TCALC disp_mult = fr_details.x;
            const int95_t vs_x = int95Sum(parent_x, parent_x_ovrf, disp_mult * dx);
            __stwb(&gmem_r.xcrd[vs_atom],      vs_x.x);
            __stwb(&gmem_r.xcrd_ovrf[vs_atom], vs_x.y);
            const int95_t vs_y = int95Sum(parent_y, parent_y_ovrf, disp_mult * dy);
            __stwb(&gmem_r.ycrd[vs_atom],      vs_y.x);
            __stwb(&gmem_r.ycrd_ovrf[vs_atom], vs_y.y);
            const int95_t vs_z = int95Sum(parent_z, parent_z_ovrf, disp_mult * dz);
            __stwb(&gmem_r.zcrd[vs_atom],      vs_z.x);
            __stwb(&gmem_r.zcrd_ovrf[vs_atom], vs_z.y);
#endif
          }
          break;
        case VirtualSiteKind::FIXED_2:
          {
#ifdef TCALC_IS_SINGLE
            const TCALC dx = (TCALC)(frame2_x - parent_x);
            const TCALC dy = (TCALC)(frame2_y - parent_y);
            const TCALC dz = (TCALC)(frame2_z - parent_z);
#else
            const TCALC dx = int95SumToDouble(frame2_x, frame2_x_ovrf, -parent_x, -parent_x_ovrf);
            const TCALC dy = int95SumToDouble(frame2_y, frame2_y_ovrf, -parent_y, -parent_y_ovrf);
            const TCALC dz = int95SumToDouble(frame2_z, frame2_z_ovrf, -parent_z, -parent_z_ovrf);
#endif
            const TCALC invr = (TCALC)(1.0) / SQRT_FUNC((dx * dx) + (dy * dy) + (dz * dz));

            // The presence of a distance in the above expression requires normalization by the
            // scaling factor, but only one multiplication operation is needed.
            const TCALC disp_mult = fr_details.x * invr * poly_psw.gpos_scale;
#ifdef TCALC_IS_SINGLE
            __stwb(&gmem_r.xcrd[vs_atom], parent_x + LLCONV_FUNC(dx * disp_mult));
            __stwb(&gmem_r.ycrd[vs_atom], parent_y + LLCONV_FUNC(dy * disp_mult));
            __stwb(&gmem_r.zcrd[vs_atom], parent_z + LLCONV_FUNC(dz * disp_mult));
#else
            const int95_t vs_x = int95Sum(parent_x, parent_x_ovrf, disp_mult * dx);
            __stwb(&gmem_r.xcrd[vs_atom],      vs_x.x);
            __stwb(&gmem_r.xcrd_ovrf[vs_atom], vs_x.y);
            const int95_t vs_y = int95Sum(parent_y, parent_y_ovrf, disp_mult * dy);
            __stwb(&gmem_r.ycrd[vs_atom],      vs_y.x);
            __stwb(&gmem_r.ycrd_ovrf[vs_atom], vs_y.y);
            const int95_t vs_z = int95Sum(parent_z, parent_z_ovrf, disp_mult * dz);
            __stwb(&gmem_r.zcrd[vs_atom],      vs_z.x);
            __stwb(&gmem_r.zcrd_ovrf[vs_atom], vs_z.y);
#endif
          }
          break;
        case VirtualSiteKind::FLEX_3:
          {
            const int frame3_atom = (tinsr.y & 0x3ff) + EXCL_GMEM_OFFSET;
            const llint frame3_x = __ldca(&gmem_r.xcrd[frame3_atom]);
            const llint frame3_y = __ldca(&gmem_r.ycrd[frame3_atom]);
            const llint frame3_z = __ldca(&gmem_r.zcrd[frame3_atom]);
#ifdef TCALC_IS_SINGLE
            const TCALC p_f2x = (TCALC)(frame2_x - parent_x);
            const TCALC p_f2y = (TCALC)(frame2_y - parent_y);
            const TCALC p_f2z = (TCALC)(frame2_z - parent_z);
            const TCALC p_f3x = (TCALC)(frame3_x - parent_x);
            const TCALC p_f3y = (TCALC)(frame3_y - parent_y);
            const TCALC p_f3z = (TCALC)(frame3_z - parent_z);
            __stwb(&gmem_r.xcrd[vs_atom], parent_x + LLCONV_FUNC((p_f2x * fr_details.x) +
                                                                 (p_f3x * fr_details.y)));
            __stwb(&gmem_r.ycrd[vs_atom], parent_y + LLCONV_FUNC((p_f2y * fr_details.x) +
                                                                 (p_f3y * fr_details.y))); 
            __stwb(&gmem_r.zcrd[vs_atom], parent_z + LLCONV_FUNC((p_f2z * fr_details.x) +
                                                                 (p_f3z * fr_details.y))); 
#else
            const int frame3_x_ovrf =  __ldca(&gmem_r.xcrd_ovrf[frame3_atom]);
            const int frame3_y_ovrf =  __ldca(&gmem_r.ycrd_ovrf[frame3_atom]);
            const int frame3_z_ovrf =  __ldca(&gmem_r.zcrd_ovrf[frame3_atom]);
            const TCALC p_f2x = int95SumToDouble( frame2_x,  frame2_x_ovrf,
                                                 -parent_x, -parent_x_ovrf);
            const TCALC p_f2y = int95SumToDouble( frame2_x,  frame2_x_ovrf,
                                                 -parent_x, -parent_x_ovrf);
            const TCALC p_f2z = int95SumToDouble( frame2_x,  frame2_x_ovrf,
                                                 -parent_x, -parent_x_ovrf);
            const TCALC p_f3x = int95SumToDouble( frame3_x,  frame3_x_ovrf,
                                                 -parent_x, -parent_x_ovrf);
            const TCALC p_f3y = int95SumToDouble( frame3_x,  frame3_x_ovrf,
                                                 -parent_x, -parent_x_ovrf);
            const TCALC p_f3z = int95SumToDouble( frame3_x,  frame3_x_ovrf,
                                                 -parent_x, -parent_x_ovrf);
            const int95_t vs_x = int95Sum(parent_x, parent_x_ovrf,
                                          (p_f2x * fr_details.x) + (p_f3x * fr_details.y));
            __stwb(&gmem_r.xcrd[vs_atom],      vs_x.x);
            __stwb(&gmem_r.xcrd_ovrf[vs_atom], vs_x.y);
            const int95_t vs_y = int95Sum(parent_y, parent_y_ovrf,
                                          (p_f2y * fr_details.x) + (p_f3y * fr_details.y));
            __stwb(&gmem_r.ycrd[vs_atom],      vs_y.x);
            __stwb(&gmem_r.ycrd_ovrf[vs_atom], vs_y.y);
            const int95_t vs_z = int95Sum(parent_z, parent_z_ovrf,
                                          (p_f2z * fr_details.x) + (p_f3z * fr_details.y));
            __stwb(&gmem_r.zcrd[vs_atom],      vs_z.x);
            __stwb(&gmem_r.zcrd_ovrf[vs_atom], vs_z.y);
#endif
          }
          break;
        case VirtualSiteKind::FIXED_3:
          {
            const int frame3_atom = (tinsr.y & 0x3ff) + EXCL_GMEM_OFFSET;
            const llint frame3_x = __ldca(&gmem_r.xcrd[frame3_atom]);
            const llint frame3_y = __ldca(&gmem_r.ycrd[frame3_atom]);
            const llint frame3_z = __ldca(&gmem_r.zcrd[frame3_atom]);
#ifdef TCALC_IS_SINGLE
            const TCALC f2_f3x = (TCALC)(frame3_x - frame2_x);
            const TCALC f2_f3y = (TCALC)(frame3_y - frame2_y);
            const TCALC f2_f3z = (TCALC)(frame3_z - frame2_z);
            const llint midpt_x = frame2_x + LLCONV_FUNC(fr_details.y * f2_f3x);
            const llint midpt_y = frame2_y + LLCONV_FUNC(fr_details.y * f2_f3y);
            const llint midpt_z = frame2_z + LLCONV_FUNC(fr_details.y * f2_f3z);
            const TCALC dmx = (TCALC)(midpt_x - parent_x);
            const TCALC dmy = (TCALC)(midpt_y - parent_y);
            const TCALC dmz = (TCALC)(midpt_z - parent_z);
#else
            const int frame3_x_ovrf = __ldca(&gmem_r.xcrd_ovrf[frame3_atom]);
            const int frame3_y_ovrf = __ldca(&gmem_r.ycrd_ovrf[frame3_atom]);
            const int frame3_z_ovrf = __ldca(&gmem_r.zcrd_ovrf[frame3_atom]);

            // Compute the midpoint location as a real-valued quantity
            const TCALC f2_f3_rx = int95SumToDouble( frame3_x,  frame3_x_ovrf,
                                                    -frame2_x, -frame2_x_ovrf);
            const int95_t midpt_x = int95Sum(frame2_x, frame2_x_ovrf, f2_f3_rx * fr_details.y);
            const TCALC dmx = int95SumToDouble(midpt_x.x, midpt_x.y, -parent_x, -parent_x_ovrf);
            const TCALC f2_f3_ry = int95SumToDouble( frame3_y,  frame3_y_ovrf,
                                                    -frame2_y, -frame2_y_ovrf);
            const int95_t midpt_y = int95Sum(frame2_y, frame2_y_ovrf, f2_f3_ry * fr_details.y);
            const TCALC dmy = int95SumToDouble(midpt_y.x, midpt_y.y, -parent_y, -parent_y_ovrf);
            const TCALC f2_f3_rz = int95SumToDouble( frame3_z,  frame3_z_ovrf,
                                                    -frame2_z, -frame2_z_ovrf);
            const int95_t midpt_z = int95Sum(frame2_z, frame2_z_ovrf, f2_f3_rz * fr_details.y);
            const TCALC dmz = int95SumToDouble(midpt_z.x, midpt_z.y, -parent_z, -parent_z_ovrf);
#endif
            const TCALC disp_mult = fr_details.x * poly_psw.gpos_scale /
                                    SQRT_FUNC((dmx * dmx) + (dmy * dmy) + (dmz * dmz));
#ifdef TCALC_IS_SINGLE
            __stwb(&gmem_r.xcrd[vs_atom], parent_x + LLCONV_FUNC(disp_mult * dmx));
            __stwb(&gmem_r.ycrd[vs_atom], parent_y + LLCONV_FUNC(disp_mult * dmy));
            __stwb(&gmem_r.zcrd[vs_atom], parent_z + LLCONV_FUNC(disp_mult * dmz));
#else
            const int95_t vs_x = int95Sum(parent_x, parent_x_ovrf, disp_mult * dmx);
            __stwb(&gmem_r.xcrd[vs_atom],      vs_x.x);
            __stwb(&gmem_r.xcrd_ovrf[vs_atom], vs_x.y);
            const int95_t vs_y = int95Sum(parent_y, parent_y_ovrf, disp_mult * dmy);
            __stwb(&gmem_r.ycrd[vs_atom],      vs_y.x);
            __stwb(&gmem_r.ycrd_ovrf[vs_atom], vs_y.y);
            const int95_t vs_z = int95Sum(parent_z, parent_z_ovrf, disp_mult * dmz);
            __stwb(&gmem_r.zcrd[vs_atom],      vs_z.x);
            __stwb(&gmem_r.zcrd_ovrf[vs_atom], vs_z.y);
#endif
          }
          break;
        case VirtualSiteKind::FAD_3:
          {
            const int frame3_atom = (tinsr.y & 0x3ff) + EXCL_GMEM_OFFSET;
            const llint frame3_x = __ldca(&gmem_r.xcrd[frame3_atom]);
            const llint frame3_y = __ldca(&gmem_r.ycrd[frame3_atom]);
            const llint frame3_z = __ldca(&gmem_r.zcrd[frame3_atom]);
#ifdef TCALC_IS_SINGLE
            const TCALC3 p_f2  = { (TCALC)(frame2_x - parent_x), (TCALC)(frame2_y - parent_y),
                                   (TCALC)(frame2_z - parent_z) };
            const TCALC3 f2_f3 = { (TCALC)(frame3_x - frame2_x), (TCALC)(frame3_y - frame2_y),
                                   (TCALC)(frame3_z - frame2_z) };
#else
            const int frame3_x_ovrf = __ldca(&gmem_r.xcrd_ovrf[frame3_atom]);
            const int frame3_y_ovrf = __ldca(&gmem_r.ycrd_ovrf[frame3_atom]);
            const int frame3_z_ovrf = __ldca(&gmem_r.zcrd_ovrf[frame3_atom]);
            const TCALC3 p_f2 = {
              int95SumToDouble(frame2_x, frame2_x_ovrf, -parent_x, -parent_x_ovrf),
              int95SumToDouble(frame2_y, frame2_y_ovrf, -parent_y, -parent_y_ovrf),
              int95SumToDouble(frame2_z, frame2_z_ovrf, -parent_z, -parent_z_ovrf) };
            const TCALC3 f2_f3 = {
              int95SumToDouble(frame3_x, frame3_x_ovrf, -frame2_x, -frame2_x_ovrf),
              int95SumToDouble(frame3_y, frame3_y_ovrf, -frame2_y, -frame2_y_ovrf),
              int95SumToDouble(frame3_z, frame3_z_ovrf, -frame2_z, -frame2_z_ovrf) };
#endif
            const TCALC invr2_p_f2 = (TCALC)(1.0) / ((p_f2.x * p_f2.x) + (p_f2.y * p_f2.y) +
                                                     (p_f2.z * p_f2.z));
            const TCALC3 f23_t_pf2 = project(f2_f3, p_f2);
            const TCALC invr_p_f2 = (TCALC)(1.0) / SQRT_FUNC((p_f2.x * p_f2.x) +
                                                             (p_f2.y * p_f2.y) +
                                                             (p_f2.z * p_f2.z));
            const TCALC invr_t = (TCALC)(1.0) / SQRT_FUNC((f23_t_pf2.x * f23_t_pf2.x) +
                                                          (f23_t_pf2.y * f23_t_pf2.y) +
                                                          (f23_t_pf2.z * f23_t_pf2.z));
            const TCALC scaled_dim1 = fr_details.x * poly_psw.gpos_scale;
            const TCALC p_f2_factor = scaled_dim1 * COS_FUNC(fr_details.y) * invr_p_f2;
            const TCALC t_factor    = scaled_dim1 * SIN_FUNC(fr_details.y) * invr_t;
#ifdef TCALC_IS_SINGLE
            __stwb(&gmem_r.xcrd[vs_atom], parent_x + LLCONV_FUNC((p_f2_factor * p_f2.x) +
                                                                 (t_factor * f23_t_pf2.x)));
            __stwb(&gmem_r.ycrd[vs_atom], parent_y + LLCONV_FUNC((p_f2_factor * p_f2.y) +
                                                                 (t_factor * f23_t_pf2.y)));
            __stwb(&gmem_r.zcrd[vs_atom], parent_z + LLCONV_FUNC((p_f2_factor * p_f2.z) +
                                                                 (t_factor * f23_t_pf2.z)));
#else
            const int95_t vs_x = int95Sum(parent_x, parent_x_ovrf,
                                          (p_f2_factor * p_f2.x) + (t_factor * f23_t_pf2.x));
            __stwb(&gmem_r.xcrd[vs_atom],      vs_x.x);
            __stwb(&gmem_r.xcrd_ovrf[vs_atom], vs_x.y);
            const int95_t vs_y = int95Sum(parent_y, parent_y_ovrf,
                                          (p_f2_factor * p_f2.y) + (t_factor * f23_t_pf2.y));
            __stwb(&gmem_r.ycrd[vs_atom],      vs_y.x);
            __stwb(&gmem_r.ycrd_ovrf[vs_atom], vs_y.y);
            const int95_t vs_z = int95Sum(parent_z, parent_z_ovrf,
                                          (p_f2_factor * p_f2.z) + (t_factor * f23_t_pf2.z));
            __stwb(&gmem_r.zcrd[vs_atom],      vs_z.x);
            __stwb(&gmem_r.zcrd_ovrf[vs_atom], vs_z.y);
#endif
          }
          break;
        case VirtualSiteKind::OUT_3:
          {
            const int frame3_atom = (tinsr.y & 0x3ff) + EXCL_GMEM_OFFSET;
            const llint frame3_x = __ldca(&gmem_r.xcrd[frame3_atom]);
            const llint frame3_y = __ldca(&gmem_r.ycrd[frame3_atom]);
            const llint frame3_z = __ldca(&gmem_r.zcrd[frame3_atom]);
#ifdef TCALC_IS_SINGLE
            const TCALC3 p_f2 = { (TCALC)(frame2_x - parent_x), (TCALC)(frame2_y - parent_y),
                                  (TCALC)(frame2_z - parent_z) };
            const TCALC3 p_f3 = { (TCALC)(frame3_x - parent_x), (TCALC)(frame3_y - parent_y),
                                  (TCALC)(frame3_z - parent_z) };
#else
            const int frame3_x_ovrf = __ldca(&gmem_r.xcrd_ovrf[frame3_atom]);
            const int frame3_y_ovrf = __ldca(&gmem_r.ycrd_ovrf[frame3_atom]);
            const int frame3_z_ovrf = __ldca(&gmem_r.zcrd_ovrf[frame3_atom]);
            const TCALC3 p_f2 = {
              int95SumToDouble(frame2_x, frame2_x_ovrf, -parent_x, -parent_x_ovrf),
              int95SumToDouble(frame2_y, frame2_y_ovrf, -parent_y, -parent_y_ovrf),
              int95SumToDouble(frame2_z, frame2_z_ovrf, -parent_z, -parent_z_ovrf) };
            const TCALC3 p_f3 = {
              int95SumToDouble(frame3_x, frame3_x_ovrf, -parent_x, -parent_x_ovrf),
              int95SumToDouble(frame3_y, frame3_y_ovrf, -parent_y, -parent_y_ovrf),
              int95SumToDouble(frame3_z, frame3_z_ovrf, -parent_z, -parent_z_ovrf) };
#endif
            const TCALC3 pf2_x_pf3 = crossProduct(p_f2, p_f3);
#ifdef TCALC_IS_SINGLE
            __stwb(&gmem_r.xcrd[vs_atom],
                   parent_x + LLCONV_FUNC((fr_details.x * p_f2.x) + (fr_details.y * p_f3.x) +
                                          (fr_details.z * pf2_x_pf3.x * poly_psw.inv_gpos_scale)));
            __stwb(&gmem_r.ycrd[vs_atom],
                   parent_y + LLCONV_FUNC((fr_details.x * p_f2.y) + (fr_details.y * p_f3.y) +
                                          (fr_details.z * pf2_x_pf3.y * poly_psw.inv_gpos_scale)));
            __stwb(&gmem_r.zcrd[vs_atom],
                   parent_z + LLCONV_FUNC((fr_details.x * p_f2.z) + (fr_details.y * p_f3.z) +
                                          (fr_details.z * pf2_x_pf3.z * poly_psw.inv_gpos_scale)));
#else
            const int95_t vs_x = int95Sum(parent_x, parent_x_ovrf,
                                          (fr_details.x * p_f2.x) + (fr_details.y * p_f3.x) +
                                          (fr_details.z * pf2_x_pf3.x * poly_psw.inv_gpos_scale));
            __stwb(&gmem_r.xcrd[vs_atom],      vs_x.x);
            __stwb(&gmem_r.xcrd_ovrf[vs_atom], vs_x.y);
            const int95_t vs_y = int95Sum(parent_y, parent_y_ovrf,
                                          (fr_details.x * p_f2.y) + (fr_details.y * p_f3.y) +
                                          (fr_details.z * pf2_x_pf3.y * poly_psw.inv_gpos_scale));
            __stwb(&gmem_r.ycrd[vs_atom],      vs_y.x);
            __stwb(&gmem_r.ycrd_ovrf[vs_atom], vs_y.y);
            const int95_t vs_z = int95Sum(parent_z, parent_z_ovrf,
                                          (fr_details.x * p_f2.z) + (fr_details.y * p_f3.z) +
                                          (fr_details.z * pf2_x_pf3.z * poly_psw.inv_gpos_scale));
            __stwb(&gmem_r.zcrd[vs_atom],      vs_z.x);
            __stwb(&gmem_r.zcrd_ovrf[vs_atom], vs_z.y);
#endif
          }
          break;
        case VirtualSiteKind::FIXED_4:
          {
            const int frame3_atom = (tinsr.y & 0x3ff) + EXCL_GMEM_OFFSET;
            const int frame4_atom = ((tinsr.y >> 10) & 0x3ff) + EXCL_GMEM_OFFSET;
            const llint frame3_x = __ldca(&gmem_r.xcrd[frame3_atom]);
            const llint frame3_y = __ldca(&gmem_r.ycrd[frame3_atom]);
            const llint frame3_z = __ldca(&gmem_r.zcrd[frame3_atom]);
            const llint frame4_x = __ldca(&gmem_r.xcrd[frame4_atom]);
            const llint frame4_y = __ldca(&gmem_r.ycrd[frame4_atom]);
            const llint frame4_z = __ldca(&gmem_r.zcrd[frame4_atom]);
#ifdef TCALC_IS_SINGLE
            const TCALC p_f2x = (TCALC)(frame2_x - parent_x);
            const TCALC p_f2y = (TCALC)(frame2_y - parent_y);
            const TCALC p_f2z = (TCALC)(frame2_z - parent_z);
            const TCALC p_f3x = (TCALC)(frame3_x - parent_x);
            const TCALC p_f3y = (TCALC)(frame3_y - parent_y);
            const TCALC p_f3z = (TCALC)(frame3_z - parent_z);
            const TCALC p_f4x = (TCALC)(frame4_x - parent_x);
            const TCALC p_f4y = (TCALC)(frame4_y - parent_y);
            const TCALC p_f4z = (TCALC)(frame4_z - parent_z);
#else
            const int frame3_x_ovrf =  __ldca(&gmem_r.xcrd_ovrf[frame3_atom]);
            const int frame3_y_ovrf =  __ldca(&gmem_r.ycrd_ovrf[frame3_atom]);
            const int frame3_z_ovrf =  __ldca(&gmem_r.zcrd_ovrf[frame3_atom]);
            const int frame4_x_ovrf =  __ldca(&gmem_r.xcrd_ovrf[frame4_atom]);
            const int frame4_y_ovrf =  __ldca(&gmem_r.ycrd_ovrf[frame4_atom]);
            const int frame4_z_ovrf =  __ldca(&gmem_r.zcrd_ovrf[frame4_atom]);
            const TCALC p_f2x = int95SumToDouble( frame2_x,  frame2_x_ovrf,
                                                 -parent_x, -parent_x_ovrf);
            const TCALC p_f2y = int95SumToDouble( frame2_y,  frame2_y_ovrf,
                                                 -parent_y, -parent_y_ovrf);
            const TCALC p_f2z = int95SumToDouble( frame2_z,  frame2_z_ovrf,
                                                 -parent_z, -parent_z_ovrf);
            const TCALC p_f3x = int95SumToDouble( frame3_x,  frame3_x_ovrf,
                                                 -parent_x, -parent_x_ovrf);
            const TCALC p_f3y = int95SumToDouble( frame3_y,  frame3_y_ovrf,
                                                 -parent_y, -parent_y_ovrf);
            const TCALC p_f3z = int95SumToDouble( frame3_z,  frame3_z_ovrf,
                                                 -parent_z, -parent_z_ovrf);
            const TCALC p_f4x = int95SumToDouble( frame4_x,  frame4_x_ovrf,
                                                 -parent_x, -parent_x_ovrf);
            const TCALC p_f4y = int95SumToDouble( frame4_y,  frame4_y_ovrf,
                                                 -parent_y, -parent_y_ovrf);
            const TCALC p_f4z = int95SumToDouble( frame4_z,  frame4_z_ovrf,
                                                 -parent_z, -parent_z_ovrf);
#endif
            const TCALC3 pf3_m_pf2 = { (fr_details.x * p_f3x) - p_f2x,
                                       (fr_details.x * p_f3y) - p_f2y,
                                       (fr_details.x * p_f3z) - p_f2z };
            const TCALC3 pf4_m_pf2 = { (fr_details.y * p_f4x) - p_f2x,
                                       (fr_details.y * p_f4y) - p_f2y,
                                       (fr_details.y * p_f4z) - p_f2z };
            const TCALC3 p_vs = crossProduct(pf3_m_pf2, pf4_m_pf2);
            const TCALC pvs_factor = fr_details.z * poly_psw.gpos_scale /
                                     SQRT_FUNC((p_vs.x * p_vs.x) + (p_vs.y * p_vs.y) +
                                               (p_vs.z * p_vs.z));
#ifdef TCALC_IS_SINGLE
            __stwb(&gmem_r.xcrd[vs_atom], parent_x + LLCONV_FUNC(pvs_factor * p_vs.x));
            __stwb(&gmem_r.ycrd[vs_atom], parent_y + LLCONV_FUNC(pvs_factor * p_vs.y));
            __stwb(&gmem_r.zcrd[vs_atom], parent_z + LLCONV_FUNC(pvs_factor * p_vs.z));
#else
            const int95_t vs_x = int95Sum(parent_x, parent_x_ovrf, pvs_factor * p_vs.x);
            __stwb(&gmem_r.xcrd[vs_atom],      vs_x.x);
            __stwb(&gmem_r.xcrd_ovrf[vs_atom], vs_x.y);
            const int95_t vs_y = int95Sum(parent_y, parent_y_ovrf, pvs_factor * p_vs.y);
            __stwb(&gmem_r.ycrd[vs_atom],      vs_y.x);
            __stwb(&gmem_r.ycrd_ovrf[vs_atom], vs_y.y);
            const int95_t vs_z = int95Sum(parent_z, parent_z_ovrf, pvs_factor * p_vs.z);
            __stwb(&gmem_r.zcrd[vs_atom],      vs_z.x);
            __stwb(&gmem_r.zcrd_ovrf[vs_atom], vs_z.y);            
#endif
          }
          break;
        case VirtualSiteKind::NONE:
          break;
        }

        // With the virtual site's position now committed to the block's private memory space,
        // the question is whether to also copy the results to the global memory arrays.  This
        // will happen as part of the general position update if the placement is part of a
        // broader valence work unit, but should happen here, when the index of the virtual site
        // is at hand and each warp is as full as possible with such virtual sites.  Performing
        // this placement with the standalone kernel will replace the virtual site positions in
        // the global arrays that the underlying PhaseSpaceSynthesis deems "current." If the
        // placement is part of a broader valence work unit, the placement will go into global
        // arrays for coordinates that the underlying PhaseSpaceSynthesis deems "future."
#ifdef VSITE_STANDALONE
        const int manip_llim    = vwu_map[(size_t)(VwuAbstractMap::MANIPULATE)].x;
        const int manip_segment = ((vs_atom - EXCL_GMEM_OFFSET) >> warp_bits);
        const int manip_bitpos  = ((vs_atom - EXCL_GMEM_OFFSET) & warp_bits_mask_int); 
        const uint2 manip_mask = poly_auk.vwu_manip[manip_llim + manip_segment];
        if ((manip_mask.y >> manip_bitpos) & 0x1) {
          const size_t write_idx = __ldca(&poly_vk.vwu_imports[import_llim + vs_atom -
                                                               EXCL_GMEM_OFFSET]);
          __stwb(&poly_psw.xcrd[write_idx], __ldca(&gmem_r.xcrd[vs_atom]));
          __stwb(&poly_psw.ycrd[write_idx], __ldca(&gmem_r.ycrd[vs_atom]));
          __stwb(&poly_psw.zcrd[write_idx], __ldca(&gmem_r.zcrd[vs_atom]));
#  ifndef TCALC_IS_SINGLE
          __stwb(&poly_psw.xcrd_ovrf[write_idx], __ldca(&gmem_r.xcrd_ovrf[vs_atom]));
          __stwb(&poly_psw.ycrd_ovrf[write_idx], __ldca(&gmem_r.ycrd_ovrf[vs_atom]));
          __stwb(&poly_psw.zcrd_ovrf[write_idx], __ldca(&gmem_r.zcrd_ovrf[vs_atom]));
#  endif
        }
#endif
      }
      pos += blockDim.x;
    }

    // Synchronize after all virtual sites for this work unit have been placed.  This must happen
    // whether the kernel is called in standalone mode or as part of a broader work unit that also
    // computes valence interactions.
    __syncthreads();
#ifdef VSITE_STANDALONE

    // No asynchronous scheduling will be provided for advancing work units that merely place
    // virtual sites.  If the placement is done as part of the valence work units, which it will
    // be in the dynamics applications that make up the more common use cases, the work units will
    // advance with the valence counter of a MolecularMechanicsControls object.
    if (threadIdx.x == 0) {
      vwu_idx += gridDim.x;
    }
    __syncthreads();
  }
}
#endif

#undef EXCL_GMEM_OFFSET
