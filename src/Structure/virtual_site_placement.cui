// -*-c++-*-
#include "copyright.h"

#define EXCL_GMEM_OFFSET  (blockIdx.x * gmem_r.max_atoms)

// The "standalone" pre-processor directive constructs a separate kernel to implement the virtual
// site placement.  Without the standalone directive, the code still assumes the availability of
// critical variables, including a phase space synthesis writeable abstract named poly_psw, a
// const valence kit (which includes valence work units and imported atom maps) named poly_vk,
// and a cache resource kit named gmem_r.
#ifdef VSITE_STANDALONE
__global__ void	__launch_bounds__(small_block_size, 4)
kPlaceVirtualSites(PsSynthesisWriter poly_psw, const SyValenceKit<TCALC> poly_vk,
                   const SyAtomUpdateKit<TCALC2, TCALC4> poly_auk,
                   const CacheResourceKit<TCALC> gmem_r) {
  __shared__ int2 vwu_map[vwu_abstract_length];
  __shared__ int vwu_task_count[vwu_abstract_length];
  __shared__ int vwu_padded_task_count[vwu_abstract_length];
  __shared__ int vwu_idx;

  if (threadIdx.x == 0) {
    vwu_idx = blockIdx.x;
  }
  __syncthreads();
  while (vwu_idx < poly_vk.nvwu) {

    // The instruction set map is read and stored in __shared__ for convenience, and to ensure
    // that it never leaves cache.  The instructions themselves are "streamed," which for purposes
    // of this documentation means read from global, used once, and not cached.  Each block must be
    // at least vwu_abstract_length + warp_size_int in size.  Currently, that is 96 on NVIDIA GPUs
    // 128 on commodity AMD GPUs, and only 64 on Intel GPUs.
    if (threadIdx.x < vwu_abstract_length) {
      vwu_map[threadIdx.x] = __ldcv(&poly_vk.vwu_abstracts[(vwu_idx * vwu_abstract_length) +
                                                           threadIdx.x]);
      vwu_task_count[threadIdx.x] = vwu_map[threadIdx.x].y - vwu_map[threadIdx.x].x;
      vwu_padded_task_count[threadIdx.x] = devcRoundUp(vwu_task_count[threadIdx.x], warp_size_int);
    }
    __syncthreads();

    // Import atomic coordinates, properties, and (if appropriate) velocities.  This employs all
    // threads of the block, breaking up each set of information at the warp level.
    const int import_llim = vwu_map[(size_t)(VwuAbstractMap::IMPORT)].x;
    const int import_hlim = vwu_map[(size_t)(VwuAbstractMap::IMPORT)].y;
    const int import_count  = import_hlim - import_llim;
    const int import_stride = devcRoundUp(import_hlim - import_llim, warp_size_int);
    int pos = threadIdx.x;
    while (pos < import_stride) {
      if (pos < import_count) {
        const size_t read_idx  = __ldca(&poly_vk.vwu_imports[import_llim + pos]);
        const size_t write_idx = EXCL_GMEM_OFFSET + pos;
        __stwb(&gmem_r.xcrd[write_idx], __ldcs(&poly_psw.xcrd[read_idx]));
#ifndef TCALC_IS_SINGLE
        __stwb(&gmem_r.xcrd_ovrf[write_idx], __ldcs(&poly_psw.xcrd_ovrf[read_idx]));
#endif
      }
      pos += blockDim.x;
    }
    while (pos < 2 * import_stride) {
      const int rel_pos = pos - import_stride;
      if (rel_pos < import_count) {
        const size_t read_idx  = __ldca(&poly_vk.vwu_imports[import_llim + rel_pos]);
        const size_t write_idx = EXCL_GMEM_OFFSET + rel_pos;
        __stwb(&gmem_r.ycrd[write_idx], __ldcs(&poly_psw.ycrd[read_idx]));
#ifndef TCALC_IS_SINGLE
        __stwb(&gmem_r.ycrd_ovrf[write_idx], __ldcs(&poly_psw.ycrd_ovrf[read_idx]));
#endif
      }
      pos += blockDim.x;
    }
    while (pos < 3 * import_stride) {
      const int rel_pos = pos - (2 * import_stride);
      if (rel_pos < import_count) {
        const size_t read_idx  = __ldca(&poly_vk.vwu_imports[import_llim + rel_pos]);
        const size_t write_idx = EXCL_GMEM_OFFSET + rel_pos;
        __stwb(&gmem_r.zcrd[write_idx], __ldcs(&poly_psw.zcrd[read_idx]));
#ifndef TCALC_IS_SINGLE
        __stwb(&gmem_r.zcrd_ovrf[write_idx], __ldcs(&poly_psw.zcrd_ovrf[read_idx]));
#endif
      }
      pos += blockDim.x;
    }
    __syncthreads();
    int vterm_limit;
#endif

    // Similar to the process with valence interaction terms, loop over all virtual site frames.
    pos = threadIdx.x;
    vterm_limit = vwu_padded_task_count[(size_t)(VwuAbstractMap::VSITE)];
    while (pos < vterm_limit) {
      if (pos < vwu_task_count[(size_t)(VwuAbstractMap::VSITE)]) {

        // Obtain the instruction
        const int task_offset = vwu_map[(size_t)(VwuAbstractMap::VSITE)].x;
        const unit2 tinsr = __ldcs(&poly_auk.vste_insr[task_offset + pos]);
        const int vs_atom = (tinsr.x & 0x3ff) + EXCL_GMEM_OFFSET;
        const int parent_atom = ((tinsr.x >> 10) & 0x3ff) + EXCL_GMEM_OFFSET;
        const int frame2_atom = ((tinsr.x >> 20) & 0x3ff) + EXCL_GMEM_OFFSET;
        const int fr_param_idx = ((tinsr.y >> 20) & 0xfff);
        const TCALC4 fr_details = poly_auk.vs_params[fr_param_idx];
        const VirtualSiteKind kind = static_cast<VirtualSiteKind>(fr_details.w);

        // The parent (first) and second frame atoms' locations must be read for any frame
        const llint parent_x = __ldca(&gmem_r.xcrd[parent_atom]);
        const llint parent_y = __ldca(&gmem_r.ycrd[parent_atom]);
        const llint parent_z = __ldca(&gmem_r.zcrd[parent_atom]);
        const llint frame2_x = __ldca(&gmem_r.xcrd[frame2_atom]);
        const llint frame2_y = __ldca(&gmem_r.ycrd[frame2_atom]);
        const llint frame2_z = __ldca(&gmem_r.zcrd[frame2_atom]);
#ifndef TCALC_IS_SINGLE
        const int parent_x_ovrf =  __ldca(&gmem_r.xcrd_ovrf[parent_atom]);
        const int parent_y_ovrf =  __ldca(&gmem_r.ycrd_ovrf[parent_atom]);
        const int parent_z_ovrf =  __ldca(&gmem_r.zcrd_ovrf[parent_atom]);
        const int frame2_x_ovrf =  __ldca(&gmem_r.xcrd_ovrf[frame2_atom]);
        const int frame2_y_ovrf =  __ldca(&gmem_r.ycrd_ovrf[frame2_atom]);
        const int frame2_z_ovrf =  __ldca(&gmem_r.zcrd_ovrf[frame2_atom]);
#endif
        switch (kind) {
        case VirtualSiteKind::FLEX_2:
          {
#ifdef TCALC_IS_SINGLE
            const TCALC dx = (TCALC)(frame2_x - parent_x);
            const TCALC dy = (TCALC)(frame2_y - parent_y);
            const TCALC dz = (TCALC)(frame2_z - parent_z);
            const TCALC disp_mult = fr_details.x;
            __stwb(&gmem_r.xcrd[vs_atom], parent_x + (llint)(dx * disp_mult));
            __stwb(&gmem_r.ycrd[vs_atom], parent_y + (llint)(dy * disp_mult));
            __stwb(&gmem_r.zcrd[vs_atom], parent_z + (llint)(dz * disp_mult));
#else
            const int95_t idx = int95Sum(frame2_x, frame2_x_ovrf, -parent_x, -parent_x_ovrf);
            const int95_t idy = int95Sum(frame2_y, frame2_y_ovrf, -parent_y, -parent_y_ovrf);
            const int95_t idz = int95Sum(frame2_z, frame2_z_ovrf, -parent_z, -parent_z_ovrf);
            const TCALC dx = splitFPToReal(idx);
            const TCALC dy = splitFPToReal(idy);
            const TCALC dz = splitFPToReal(idz);
            const TCALC disp_mult = fr_details.x;
            const int95_t dvsx = doubleToInt95(disp_mult * dx);
            const int95_t vs_x = int95Sum(dvsx.x, dvsx.y, parent_x, parent_x_ovrf);
            __stwb(&gmem_r.xcrd[vs_atom],      vs_x.x);
            __stwb(&gmem_r.xcrd_ovrf[vs_atom], vs_x.y);
            const int95_t dvsy = doubleToInt95(disp_mult * dy);
            const int95_t vs_y = int95Sum(dvsy.x, dvsy.y, parent_y, parent_y_ovrf);
            __stwb(&gmem_r.ycrd[vs_atom],      vs_y.x);
            __stwb(&gmem_r.ycrd_ovrf[vs_atom], vs_y.y);
            const int95_t dvsz = doubleToInt95(disp_mult * dz);
            const int95_t vs_z = int95Sum(dvsz.x, dvsz.y, parent_z, parent_z_ovrf);
            __stwb(&gmem_r.zcrd[vs_atom],      vs_z.x);
            __stwb(&gmem_r.zcrd_ovrf[vs_atom], vs_z.y);
#endif
          }
          break;
        case VirtualSiteKind::FIXED_2:
          {
#ifdef TCALC_IS_SINGLE
            const TCALC dx = (TCALC)(frame2_x - parent_x);
            const TCALC dy = (TCALC)(frame2_y - parent_y);
            const TCALC dz = (TCALC)(frame2_z - parent_z);
#else
            const int95_t idx = int95Sum(frame2_x, frame2_x_ovrf, -parent_x, -parent_x_ovrf);
            const int95_t idy = int95Sum(frame2_y, frame2_y_ovrf, -parent_y, -parent_y_ovrf);
            const int95_t idz = int95Sum(frame2_z, frame2_z_ovrf, -parent_z, -parent_z_ovrf);
            const TCALC dx = splitFPToReal(idx);
            const TCALC dy = splitFPToReal(idy);
            const TCALC dz = splitFPToReal(idz);
#endif
            const TCALC invr = (TCALC)(1.0) / SQRT_FUNC((dx * dx) + (dy * dy) + (dz * dz));
            const TCALC disp_mult = fr_details.x * invr;
#ifdef TCALC_IS_SINGLE
            __stwb(&gmem_r.xcrd[vs_atom], parent_x + (llint)(dx * disp_mult));
            __stwb(&gmem_r.ycrd[vs_atom], parent_y + (llint)(dy * disp_mult));
            __stwb(&gmem_r.zcrd[vs_atom], parent_z + (llint)(dz * disp_mult));
#else
            const int95_t dvsx = doubleToInt95(disp_mult * dx);
            const int95_t vs_x = int95Sum(dvsx.x, dvsx.y, parent_x, parent_x_ovrf);
            __stwb(&gmem_r.xcrd[vs_atom],      vs_x.x);
            __stwb(&gmem_r.xcrd_ovrf[vs_atom], vs_x.y);
            const int95_t dvsy = doubleToInt95(disp_mult * dy);
            const int95_t vs_y = int95Sum(dvsy.x, dvsy.y, parent_y, parent_y_ovrf);
            __stwb(&gmem_r.ycrd[vs_atom],      vs_y.x);
            __stwb(&gmem_r.ycrd_ovrf[vs_atom], vs_y.y);
            const int95_t dvsz = doubleToInt95(disp_mult * dz);
            const int95_t vs_z = int95Sum(dvsz.x, dvsz.y, parent_z, parent_z_ovrf);
            __stwb(&gmem_r.zcrd[vs_atom],      vs_z.x);
            __stwb(&gmem_r.zcrd_ovrf[vs_atom], vs_z.y);
#endif
          }
          break;
        case VirtualSiteKind::FLEX_3:
          {
            const int frame3_atom = (tinsr.y & 0x3ff) + EXCL_GMEM_OFFSET;
            const llint frame3_x = __ldca(&gmem_r.xcrd[frame3_atom]);
            const llint frame3_y = __ldca(&gmem_r.ycrd[frame3_atom]);
            const llint frame3_z = __ldca(&gmem_r.zcrd[frame3_atom]);
#ifdef TCALC_IS_SINGLE
            // Multiplying by the inverse position scaling constant, only to multiply each number
            // by the scaling constant, is unecessary and will not preserve any extra precision.
            const TCALC3 p_f2 = { (TCALC)(frame2_x - parent_x), (TCALC)(frame2_y - parent_y),
                                  (TCALC)(frame2_z - parent_z) };
            const TCALC3 p_f3 = { (TCALC)(frame3_x - parent_x), (TCALC)(frame3_y - parent_y),
                                  (TCALC)(frame3_z - parent_z) };
            __stwb(&gmem_r.xcrd[vs_atom], parent_x + (llint)((p_f2.x * fr_details.x) +
                                                             (p_f3.x * fr_details.y)));
            __stwb(&gmem_r.ycrd[vs_atom], parent_y + (llint)((p_f2.y * fr_details.x) +
                                                             (p_f3.y * fr_details.y))); 
            __stwb(&gmem_r.zcrd[vs_atom], parent_z + (llint)((p_f2.z * fr_details.x) +
                                                             (p_f3.z * fr_details.y))); 
#else
            const int frame3_x_ovrf =  __ldca(&gmem_r.xcrd_ovrf[frame3_atom]);
            const int frame3_y_ovrf =  __ldca(&gmem_r.ycrd_ovrf[frame3_atom]);
            const int frame3_z_ovrf =  __ldca(&gmem_r.zcrd_ovrf[frame3_atom]);
            const int95t p_f2_xcmb = int95Sum(frame2_x, frame2_x_ovrf, -parent_x, -parent_x_ovrf);
            const int95t p_f2_ycmb = int95Sum(frame2_y, frame2_y_ovrf, -parent_y, -parent_y_ovrf);
            const int95t p_f2_zcmb = int95Sum(frame2_z, frame2_z_ovrf, -parent_z, -parent_z_ovrf);
            const TCALC3 p_f2 = { splitFPToReal(p_f2_xcmb), splitFPToReal(p_f2_ycmb),
                                  splitFPToReal(p_f2_zcmb) };
            const int95t p_f3_xcmb = int95Sum(frame3_x, frame3_x_ovrf, -parent_x, -parent_x_ovrf);
            const int95t p_f3_ycmb = int95Sum(frame3_y, frame3_y_ovrf, -parent_y, -parent_y_ovrf);
            const int95t p_f3_zcmb = int95Sum(frame3_z, frame3_z_ovrf, -parent_z, -parent_z_ovrf);
            const TCALC3 p_f3 = { splitFPToReal(p_f3_xcmb), splitFPToReal(p_f3_ycmb),
                                  splitFPToReal(p_f3_zcmb) };
            const int95_t dvsx = doubleToInt95((p_f2.x * fr_details.x) + (p_f3.x * fr_details.y));
            const int95_t vs_x = int95Sum(dvsx.x, dvsx.y, parent_x, parent_x_ovrf);
            __stwb(&gmem_r.xcrd[vs_atom],      vs_x.x);
            __stwb(&gmem_r.xcrd_ovrf[vs_atom], vs_x.y);
            const int95_t dvsy = doubleToInt95((p_f2.y * fr_details.x) + (p_f3.y * fr_details.y));
            const int95_t vs_y = int95Sum(dvsy.x, dvsy.y, parent_y, parent_y_ovrf);
            __stwb(&gmem_r.ycrd[vs_atom],      vs_y.x);
            __stwb(&gmem_r.ycrd_ovrf[vs_atom], vs_y.y);
            const int95_t dvsz = doubleToInt95((p_f2.z * fr_details.x) + (p_f3.z * fr_details.y));
            const int95_t vs_z = int95Sum(dvsz.x, dvsz.y, parent_z, parent_z_ovrf);
            __stwb(&gmem_r.zcrd[vs_atom],      vs_z.x);
            __stwb(&gmem_r.zcrd_ovrf[vs_atom], vs_z.y);
#endif
          }
          break;
        case VirtualSiteKind::FIXED_3:
          {
            const int frame3_atom = (tinsr.y & 0x3ff) + EXCL_GMEM_OFFSET;
            const llint frame3_x = __ldca(&gmem_r.xcrd[frame3_atom]);
            const llint frame3_y = __ldca(&gmem_r.ycrd[frame3_atom]);
            const llint frame3_z = __ldca(&gmem_r.zcrd[frame3_atom]);
#ifdef TCALC_IS_SINGLE
            const TCALC3 f2_f3 = { (TCALC)(frame3_x - frame2_x), (TCALC)(frame3_y - frame2_y),
                                   (TCALC)(frame3_z - frame2_z) };
            const llint midpt_x = frame2_x + (llint)(fr_details.y * f2_f3.x);
            const llint midpt_y = frame2_y + (llint)(fr_details.y * f2_f3.y);
            const llint midpt_z = frame2_z + (llint)(fr_details.y * f2_f3.z);
            const TCALC3 dm = { (TCALC)(midpt_x - parent_x), (TCALC)(midpt_y - parent_y),
                                (TCALC)(midpt_z - parent_z) };
#else
            const int frame3_x_ovrf = __ldca(&gmem_r.xcrd_ovrf[frame3_atom]);
            const int frame3_y_ovrf = __ldca(&gmem_r.ycrd_ovrf[frame3_atom]);
            const int frame3_z_ovrf = __ldca(&gmem_r.zcrd_ovrf[frame3_atom]);

            // Compute the midpoint location as a real-valued quantity
            const int95_t f2_f3_xcmb = int95Sum( frame3_x,  frame3_x_ovrf,
                                                -frame2_x, -frame2_x_ovrf);
            const TCALC f2_f3_rx = splitFPToReal(f2_f3_xcmb);
            const int95_t disp_x = doubleToInt95(f2_f3_rx * fr_details.y);
            const int95_t midpt_x = int95Sum(frame2_x, frame2_x_ovrf, disp_x.x, disp_x.y);
            const int95_t dm_x = int95Sum(midpt_x.x, midpt_x.y, -parent_x, -parent_x_ovrf);
            const int95_t f2_f3_ycmb = int95Sum( frame3_y,  frame3_y_ovrf,
                                                -frame2_y, -frame2_y_ovrf);
            const TCALC f2_f3_ry = splitFPToReal(f2_f3_ycmb)
            const int95_t disp_y = doubleToInt95(f2_f3_ry * fr_details.y);
            const int95_t midpt_y = int95Sum(frame2_y, frame2_y_ovrf, disp_y.x, disp_y.y);
            const int95_t dm_y = int95Sum(midpt_y.x, midpt_y.y, -parent_y, -parent_y_ovrf);
            const int95_t f2_f3_zcmb = int95Sum( frame3_z,  frame3_z_ovrf,
                                                -frame2_z, -frame2_z_ovrf);
            const TCALC f2_f3_rz = splitFPToReal(f2_f3_zcmb);
            const int95_t disp_z = doubleToInt95(f2_f3_rz * fr_details.y);
            const int95_t midpt_z = int95Sum(frame2_z, frame2_z_ovrf, disp_z.x, disp_z.y);
            const int95_t dm_z = int95Sum(midpt_z.x, midpt_z.y,
                                          -parent_z, -parent_z_ovrf);
            const TCALC3 dm = { splitFPToReal(dm_x), splitFPToReal(dm_y), splitFPToReal(dm_z) };
#endif
            const TCALC invr = (TCALC)(1.0) / ((dm.x * dm.x) + (dm.y * dm.y) + (dm.z * dm.z));
            const TCALC disp_mult = fr_details.x * invr;
#ifdef TCALC_IS_SINGLE
            __stwb(&gmem_r.xcrd[vs_atom], parent_x + (llint)(disp_mult * dm.x));
            __stwb(&gmem_r.ycrd[vs_atom], parent_y + (llint)(disp_mult * dm.y));
            __stwb(&gmem_r.zcrd[vs_atom], parent_z + (llint)(disp_mult * dm.z));
#else
            
#endif
          }
          break;
        case VirtualSiteKind::FAD_3:
          
          break;
        case VirtualSiteKind::OUT_3:
          break;
        case VirtualSiteKind::FIXED_4:
          {
            const int frame3_atom = (tinsr.y & 0x3ff) + EXCL_GMEM_OFFSET;
            const int frame4_atom = ((tinsr.y >> 10) & 0x3ff) + EXCL_GMEM_OFFSET;
            const llint frame3_x = __ldca(&gmem_r.xcrd[frame3_atom]);
            const llint frame3_y = __ldca(&gmem_r.ycrd[frame3_atom]);
            const llint frame3_z = __ldca(&gmem_r.zcrd[frame3_atom]);
            const llint frame4_x = __ldca(&gmem_r.xcrd[frame4_atom]);
            const llint frame4_y = __ldca(&gmem_r.ycrd[frame4_atom]);
            const llint frame4_z = __ldca(&gmem_r.zcrd[frame4_atom]);
#ifdef TCALC_IS_SINGLE
            const TCALC3 p_f2 = { (TCALC)(frame2_x - parent_x), (TCALC)(frame2_y - parent_y),
                                  (TCALC)(frame2_z - parent_z) };
            const TCALC3 p_f3 = { (TCALC)(frame3_x - parent_x), (TCALC)(frame3_y - parent_y),
                                  (TCALC)(frame3_z - parent_z) };
            const TCALC3 p_f4 = { (TCALC)(frame4_x - parent_x), (TCALC)(frame4_y - parent_y),
                                  (TCALC)(frame4_z - parent_z) };
#else
            const int frame3_x_ovrf =  __ldca(&gmem_r.xcrd_ovrf[frame3_atom]);
            const int frame3_y_ovrf =  __ldca(&gmem_r.ycrd_ovrf[frame3_atom]);
            const int frame3_z_ovrf =  __ldca(&gmem_r.zcrd_ovrf[frame3_atom]);
            const int frame4_x_ovrf =  __ldca(&gmem_r.xcrd_ovrf[frame4_atom]);
            const int frame4_y_ovrf =  __ldca(&gmem_r.ycrd_ovrf[frame4_atom]);
            const int frame4_z_ovrf =  __ldca(&gmem_r.zcrd_ovrf[frame4_atom]);
            const int95_t p_f2_xcmb = int95Sum(frame2_x, frame2_x_ovrf, -parent_x, -parent_x_ovrf);
            const int95_t p_f2_ycmb = int95Sum(frame2_y, frame2_y_ovrf, -parent_y, -parent_y_ovrf);
            const int95_t p_f2_zcmb = int95Sum(frame2_z, frame2_z_ovrf, -parent_z, -parent_z_ovrf);
            const TCALC3 p_f2 = { int95ToDouble(p_f2_xcmb), int95ToDouble(p_f2_ycmb),
                                  int95ToDouble(p_f2_zcmb) };
            const int95_t p_f3_xcmb = int95Sum(frame3_x, frame3_x_ovrf, -parent_x, -parent_x_ovrf);
            const int95_t p_f3_ycmb = int95Sum(frame3_y, frame3_y_ovrf, -parent_y, -parent_y_ovrf);
            const int95_t p_f3_zcmb = int95Sum(frame3_z, frame3_z_ovrf, -parent_z, -parent_z_ovrf);
            const TCALC3 p_f3 = { int95ToDouble(p_f3_xcmb), int95ToDouble(p_f3_ycmb),
                                  int95ToDouble(p_f3_zcmb) };
            const int95_t p_f4_xcmb = int95Sum(frame4_x, frame4_x_ovrf, -parent_x, -parent_x_ovrf);
            const int95_t p_f4_ycmb = int95Sum(frame4_y, frame4_y_ovrf, -parent_y, -parent_y_ovrf);
            const int95_t p_f4_zcmb = int95Sum(frame4_z, frame4_z_ovrf, -parent_z, -parent_z_ovrf);
            const TCALC3 p_f4 = { int95ToDouble(p_f4_xcmb), int95ToDouble(p_f4_ycmb),
                                  int95ToDouble(p_f4_zcmb) };
#endif
            const TCALC3 pf3_m_pf2 = { (fr_details.x * p_f3.x) - p_f2.x,
                                       (fr_details.x * p_f3.y) - p_f2.y,
                                       (fr_details.x * p_f3.z) - p_f2.z };
            const TCALC3 pf4_m_pf2 = { (fr_details.y * p_f4.x) - p_f2.x,
                                       (fr_details.y * p_f4.y) - p_f2.y,
                                       (fr_details.y * p_f4.z) - p_f2.z };
            const TCALC3 p_vs = crossProduct(pf3_m_pf2, pf4_m_pf2);
            const TCALC pvs_factor = fr_details.z / SQRT_FUNC((p_vs.x * p_vs.x) +
                                                              (p_vs.y * p_vs.y) +
                                                              (p_vs.z * p_vs.z));
#ifdef TCALC_IS_SINGLE
            __stwb(&gmem_r.xcrd[vs_atom], parent_x + (llint)(pvs_factor * p_vs.x));
            __stwb(&gmem_r.ycrd[vs_atom], parent_y + (llint)(pvs_factor * p_vs.y));
            __stwb(&gmem_r.zcrd[vs_atom], parent_z + (llint)(pvs_factor * p_vs.z));
#else
            const int95_t dvsx = doubleToInt95(pvs_factor * p_vs.x);
            const int95_t vs_x = int95Sum(dvsx.x, dvsx.y, parent_x, parent_x_ovrf);
            __stwb(&gmem_r.xcrd[vs_atom],      vs_x.x);
            __stwb(&gmem_r.xcrd_ovrf[vs_atom], vs_x.y);
            const int95_t dvsy = doubleToInt95(pvs_factor * p_vs.y);
            const int95_t vs_y = int95Sum(dvsy.x, dvsy.y, parent_y, parent_y_ovrf);
            __stwb(&gmem_r.ycrd[vs_atom],      vs_y.x);
            __stwb(&gmem_r.ycrd_ovrf[vs_atom], vs_y.y);
            const int95_t dvsz = doubleToInt95(pvs_factor * p_vs.z);
            const int95_t vs_z = int95Sum(dvsz.x, dvsz.y, parent_z, parent_z_ovrf);
            __stwb(&gmem_r.zcrd[vs_atom],      vs_z.x);
            __stwb(&gmem_r.zcrd_ovrf[vs_atom], vs_z.y);            
#endif
          }
          break;
        }
      }
    }
    
#ifdef VSITE_STANDALONE
  }
}
#endif

#undef EXCL_GMEM_OFFSET
