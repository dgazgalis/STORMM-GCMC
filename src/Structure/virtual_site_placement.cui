// -*-c++-*-
#include "copyright.h"

#define EXCL_GMEM_OFFSET  (blockIdx.x * gmem_r.max_atoms)

// The "standalone" pre-processor directive constructs a separate kernel to implement the virtual
// site placement.  Without the standalone directive, the code still assumes the availability of
// critical variables, including a phase space synthesis writeable abstract named poly_psw, a
// const valence kit (which includes valence work units and imported atom maps) named poly_vk,
// and a cache resource kit named gmem_r.
#ifdef VSITE_STANDALONE
__global__ void	__launch_bounds__(small_block_size, 4)
kPlaceVirtualSites(PsSynthesisWriter poly_psw, const SyValenceKit<TCALC> poly_vk,
                   const SyAtomUpdateKit<TCALC2, TCALC4> poly_auk,
                   const CacheResourceKit<TCALC> gmem_r) {
  __shared__ int2 vwu_map[vwu_abstract_length];
  __shared__ int vwu_task_count[vwu_abstract_length];
  __shared__ int vwu_padded_task_count[vwu_abstract_length];
  __shared__ int vwu_idx;

  if (threadIdx.x == 0) {
    vwu_idx = blockIdx.x;
  }
  __syncthreads();
  while (vwu_idx < poly_vk.nvwu) {

    // The instruction set map is read and stored in __shared__ for convenience, and to ensure
    // that it never leaves cache.  The instructions themselves are "streamed," which for purposes
    // of this documentation means read from global, used once, and not cached.  Each block must be
    // at least vwu_abstract_length + warp_size_int in size.  Currently, that is 96 on NVIDIA GPUs
    // 128 on commodity AMD GPUs, and only 64 on Intel GPUs.
    if (threadIdx.x < vwu_abstract_length) {
      vwu_map[threadIdx.x] = __ldcv(&poly_vk.vwu_abstracts[(vwu_idx * vwu_abstract_length) +
                                                           threadIdx.x]);
      vwu_task_count[threadIdx.x] = vwu_map[threadIdx.x].y - vwu_map[threadIdx.x].x;
      vwu_padded_task_count[threadIdx.x] = devcRoundUp(vwu_task_count[threadIdx.x], warp_size_int);
    }
    __syncthreads();

    // Import atomic coordinates, properties, and (if appropriate) velocities.  This employs all
    // threads of the block, breaking up each set of information at the warp level.
    const int import_llim = vwu_map[(size_t)(VwuAbstractMap::IMPORT)].x;
    const int import_hlim = vwu_map[(size_t)(VwuAbstractMap::IMPORT)].y;
    const int import_count  = import_hlim - import_llim;
    const int import_stride = devcRoundUp(import_hlim - import_llim, warp_size_int);
    int pos = threadIdx.x;
    while (pos < import_stride) {
      if (pos < import_count) {
        const size_t read_idx  = __ldca(&poly_vk.vwu_imports[import_llim + pos]);
        const size_t write_idx = EXCL_GMEM_OFFSET + pos;
        __stwb(&gmem_r.xcrd[write_idx], __ldcs(&poly_psw.xcrd[read_idx]));
#ifndef TCALC_IS_SINGLE
        __stwb(&gmem_r.xcrd_ovrf[write_idx], __ldcs(&poly_psw.xcrd_ovrf[read_idx]));
#endif
      }
      pos += blockDim.x;
    }
    while (pos < 2 * import_stride) {
      const int rel_pos = pos - import_stride;
      if (rel_pos < import_count) {
        const size_t read_idx  = __ldca(&poly_vk.vwu_imports[import_llim + rel_pos]);
        const size_t write_idx = EXCL_GMEM_OFFSET + rel_pos;
        __stwb(&gmem_r.ycrd[write_idx], __ldcs(&poly_psw.ycrd[read_idx]));
#ifndef TCALC_IS_SINGLE
        __stwb(&gmem_r.ycrd_ovrf[write_idx], __ldcs(&poly_psw.ycrd_ovrf[read_idx]));
#endif
      }
      pos += blockDim.x;
    }
    while (pos < 3 * import_stride) {
      const int rel_pos = pos - (2 * import_stride);
      if (rel_pos < import_count) {
        const size_t read_idx  = __ldca(&poly_vk.vwu_imports[import_llim + rel_pos]);
        const size_t write_idx = EXCL_GMEM_OFFSET + rel_pos;
        __stwb(&gmem_r.zcrd[write_idx], __ldcs(&poly_psw.zcrd[read_idx]));
#ifndef TCALC_IS_SINGLE
        __stwb(&gmem_r.zcrd_ovrf[write_idx], __ldcs(&poly_psw.zcrd_ovrf[read_idx]));
#endif
      }
      pos += blockDim.x;
    }
    __syncthreads();
    int vterm_limit;
#endif

    // Similar to the process with valence interaction terms, loop over all virtual site frames.
    pos = threadIdx.x;
    vterm_limit = vwu_padded_task_count[(size_t)(VwuAbstractMap::VSITE)];
    while (pos < vterm_limit) {
      if (pos < vwu_task_count[(size_t)(VwuAbstractMap::VSITE)]) {

        // Obtain the instruction
        const int task_offset = vwu_map[(size_t)(VwuAbstractMap::VSITE)].x;
        const unit2 tinsr = __ldcs(&poly_auk.vste_insr[task_offset + pos]);
        const int vs_atom = (tinsr.x & 0x3ff) + EXCL_GMEM_OFFSET;
        const int parent_atom = ((tinsr.x >> 10) & 0x3ff) + EXCL_GMEM_OFFSET;
        const int frame2_atom = ((tinsr.x >> 20) & 0x3ff) + EXCL_GMEM_OFFSET;
        const int fr_param_idx = ((tinsr.y >> 20) & 0xfff);
        const TCALC4 fr_details = poly_auk.vs_params[fr_param_idx];
        const VirtualSiteKind kind = static_cast<VirtualSiteKind>(fr_details.w);

        // The parent (first) and second frame atoms' locations must be read for any frame
        const llint parent_xloc = __ldca(&gmem_r.xcrd[parent_atom]);
        const llint parent_yloc = __ldca(&gmem_r.ycrd[parent_atom]);
        const llint parent_zloc = __ldca(&gmem_r.zcrd[parent_atom]);
        const llint frame2_xloc = __ldca(&gmem_r.xcrd[frame2_atom]);
        const llint frame2_yloc = __ldca(&gmem_r.ycrd[frame2_atom]);
        const llint frame2_zloc = __ldca(&gmem_r.zcrd[frame2_atom]);
#ifndef TCALC_IS_SINGLE
        const int parent_xloc_ovrf =  __ldca(&gmem_r.xcrd_ovrf[parent_atom]);
        const int parent_yloc_ovrf =  __ldca(&gmem_r.ycrd_ovrf[parent_atom]);
        const int parent_zloc_ovrf =  __ldca(&gmem_r.zcrd_ovrf[parent_atom]);
        const int frame2_xloc_ovrf =  __ldca(&gmem_r.xcrd_ovrf[frame2_atom]);
        const int frame2_yloc_ovrf =  __ldca(&gmem_r.ycrd_ovrf[frame2_atom]);
        const int frame2_zloc_ovrf =  __ldca(&gmem_r.zcrd_ovrf[frame2_atom]);
#endif
        switch (kind) {
        case VirtualSiteKind::FLEX_2:
          {
#ifdef TCALC_IS_SINGLE
            const TCALC dx = (TCALC)(frame2_xloc - parent_xloc);
            const TCALC dy = (TCALC)(frame2_yloc - parent_yloc);
            const TCALC dz = (TCALC)(frame2_zloc - parent_zloc);
            const TCALC disp_mult = fr_details.x;
            __stwb(&gmem_r.xcrd[vs_atom], parent_xloc + (llint)(dx * disp_mult));
            __stwb(&gmem_r.ycrd[vs_atom], parent_yloc + (llint)(dy * disp_mult));
            __stwb(&gmem_r.zcrd[vs_atom], parent_zloc + (llint)(dz * disp_mult));
#else
            const int95_t idx = combineSplitFixedPrecision(frame2_xloc, frame2_xloc_ovrf,
                                                           -parent_xloc, -parent_xloc_ovrf);
            const int95_t idy = combineSplitFixedPrecision(frame2_yloc, frame2_yloc_ovrf,
                                                           -parent_yloc, -parent_yloc_ovrf);
            const int95_t idz = combineSplitFixedPrecision(frame2_zloc, frame2_zloc_ovrf,
                                                           -parent_zloc, -parent_zloc_ovrf);
            const TCALC dx = (((TCALC)(idx.y) * max_llint_accumulation) + (TCALC)(idx.x));
            const TCALC dy = (((TCALC)(idy.y) * max_llint_accumulation) + (TCALC)(idy.x));
            const TCALC dz = (((TCALC)(idz.y) * max_llint_accumulation) + (TCALC)(idz.x));
            const TCALC disp_mult = fr_details.x;
            const int95_t dvsx = convertSplitFixedPrecision95(disp_mult * dx);
            const int95_t vs_x = combineSplitFixedPrecision(dvsx.x, dvsx.y, parent_xloc,
                                                            parent_xloc_ovrf);
            __stwb(&gmem_r.xcrd[vs_atom],      vs_x.x);
            __stwb(&gmem_r.xcrd_ovrf[vs_atom], vs_x.y);
            const int95_t dvsy = convertSplitFixedPrecision95(disp_mult * dy);
            const int95_t vs_y = combineSplitFixedPrecision(dvsy.x, dvsy.y, parent_yloc,
                                                            parent_yloc_ovrf);
            __stwb(&gmem_r.ycrd[vs_atom],      vs_y.x);
            __stwb(&gmem_r.ycrd_ovrf[vs_atom], vs_y.y);
            const int95_t dvsz = convertSplitFixedPrecision95(disp_mult * dz);
            const int95_t vs_z = combineSplitFixedPrecision(dvsz.x, dvsz.y, parent_zloc,
                                                            parent_zloc_ovrf);
            __stwb(&gmem_r.zcrd[vs_atom],      vs_z.x);
            __stwb(&gmem_r.zcrd_ovrf[vs_atom], vs_z.y);
#endif
          }
          break;
        case VirtualSiteKind::FIXED_2:
          {
#ifdef TCALC_IS_SINGLE
            const TCALC dx = (TCALC)(frame2_xloc - parent_xloc);
            const TCALC dy = (TCALC)(frame2_yloc - parent_yloc);
            const TCALC dz = (TCALC)(frame2_zloc - parent_zloc);
#else
            const int95_t idx = combineSplitFixedPrecision(frame2_xloc, frame2_xloc_ovrf,
                                                           -parent_xloc, -parent_xloc_ovrf);
            const int95_t idy = combineSplitFixedPrecision(frame2_yloc, frame2_yloc_ovrf,
                                                           -parent_yloc, -parent_yloc_ovrf);
            const int95_t idz = combineSplitFixedPrecision(frame2_zloc, frame2_zloc_ovrf,
                                                           -parent_zloc, -parent_zloc_ovrf);
            const TCALC dx = (((TCALC)(idx.y) * max_llint_accumulation) + (TCALC)(idx.x));
            const TCALC dy = (((TCALC)(idy.y) * max_llint_accumulation) + (TCALC)(idy.x));
            const TCALC dz = (((TCALC)(idz.y) * max_llint_accumulation) + (TCALC)(idz.x));

#endif
            const TCALC invr = (TCALC)(1.0) / SQRT_FUNC((dx * dx) + (dy * dy) + (dz * dz));
            const TCALC disp_mult = fr_details.x * invr;
#ifdef TCALC_IS_SINGLE
            __stwb(&gmem_r.xcrd[vs_atom], parent_xloc + (llint)(dx * disp_mult));
            __stwb(&gmem_r.ycrd[vs_atom], parent_yloc + (llint)(dy * disp_mult));
            __stwb(&gmem_r.zcrd[vs_atom], parent_zloc + (llint)(dz * disp_mult));
#else
            const int95_t dvsx = convertSplitFixedPrecision95(disp_mult * dx);
            const int95_t vs_x = combineSplitFixedPrecision(dvsx.x, dvsx.y, parent_xloc,
                                                            parent_xloc_ovrf);
            __stwb(&gmem_r.xcrd[vs_atom],      vs_x.x);
            __stwb(&gmem_r.xcrd_ovrf[vs_atom], vs_x.y);
            const int95_t dvsy = convertSplitFixedPrecision95(disp_mult * dy);
            const int95_t vs_y = combineSplitFixedPrecision(dvsy.x, dvsy.y, parent_yloc,
                                                            parent_yloc_ovrf);
            __stwb(&gmem_r.ycrd[vs_atom],      vs_y.x);
            __stwb(&gmem_r.ycrd_ovrf[vs_atom], vs_y.y);
            const int95_t dvsz = convertSplitFixedPrecision95(disp_mult * dz);
            const int95_t vs_z = combineSplitFixedPrecision(dvsz.x, dvsz.y, parent_zloc,
                                                            parent_zloc_ovrf);
            __stwb(&gmem_r.zcrd[vs_atom],      vs_z.x);
            __stwb(&gmem_r.zcrd_ovrf[vs_atom], vs_z.y);
#endif
          }
          break;
        case VirtualSiteKind::FLEX_3:
          {
            const int frame3_atom = (tinsr.y & 0x3ff) + EXCL_GMEM_OFFSET;
            const llint frame3_xloc = __ldca(&gmem_r.xcrd[frame3_atom]);
            const llint frame3_yloc = __ldca(&gmem_r.ycrd[frame3_atom]);
            const llint frame3_zloc = __ldca(&gmem_r.zcrd[frame3_atom]);
#ifdef TCALC_IS_SINGLE
            // Multiplying by the inverse position scaling constant, only to multiply each number
            // by the scaling constant, is unecessary and will not preserve any extra precision.
            const TCALC3 p_f2 = { (TCALC)(frame2_xloc - parent_xloc),
                                  (TCALC)(frame2_yloc - parent_yloc),
                                  (TCALC)(frame2_zloc - parent_zloc) };
            const TCALC3 p_f3 = { (TCALC)(frame3_xloc - parent_xloc),
                                  (TCALC)(frame3_yloc - parent_yloc),
                                  (TCALC)(frame3_zloc - parent_zloc) };
            __stwb(&gmem_r.xcrd[vs_atom], parent_xloc + (llint)((p_f2.x * fr_details.x) +
                                                                (p_f3.x * fr_details.y))); 
            __stwb(&gmem_r.ycrd[vs_atom], parent_yloc + (llint)((p_f2.y * fr_details.x) +
                                                                (p_f3.y * fr_details.y))); 
            __stwb(&gmem_r.zcrd[vs_atom], parent_zloc + (llint)((p_f2.z * fr_details.x) +
                                                                (p_f3.z * fr_details.y))); 
#else
            const int frame3_xloc_ovrf =  __ldca(&gmem_r.xcrd_ovrf[frame3_atom]);
            const int frame3_yloc_ovrf =  __ldca(&gmem_r.ycrd_ovrf[frame3_atom]);
            const int frame3_zloc_ovrf =  __ldca(&gmem_r.zcrd_ovrf[frame3_atom]);
            const int95t p_f2_xcmb = combineSplitFixedPrecision(frame2_xloc, frame2_xloc_ovrf,
                                                                parent_xloc, parent_xloc_ovrf);
            const int95t p_f2_ycmb = combineSplitFixedPrecision(frame2_yloc, frame2_yloc_ovrf,
                                                                parent_yloc, parent_yloc_ovrf);
            const int95t p_f2_zcmb = combineSplitFixedPrecision(frame2_zloc, frame2_zloc_ovrf,
                                                                parent_zloc, parent_zloc_ovrf);
            const TCALC3 p_f2 = { (((TCALC)(p_f2_xcmb.y) * max_llint_accumulation) +
                                   (TCALC)(p_f2_xcmb.x)),
                                  (((TCALC)(p_f2_ycmb.y) * max_llint_accumulation) +
                                   (TCALC)(p_f2_ycmb.x)),
                                  (((TCALC)(p_f2_zcmb.y) * max_llint_accumulation) +
                                   (TCALC)(p_f2_zcmb.x)) };
            const int95t p_f3_xcmb = combineSplitFixedPrecision(frame3_xloc, frame3_xloc_ovrf,
                                                                parent_xloc, parent_xloc_ovrf);
            const int95t p_f3_ycmb = combineSplitFixedPrecision(frame3_yloc, frame3_yloc_ovrf,
                                                                parent_yloc, parent_yloc_ovrf);
            const int95t p_f3_zcmb = combineSplitFixedPrecision(frame3_zloc, frame3_zloc_ovrf,
                                                                parent_zloc, parent_zloc_ovrf);
            const TCALC3 p_f3 = { (((TCALC)(p_f3_xcmb.y) * max_llint_accumulation) +
                                   (TCALC)(p_f3_xcmb.x)),
                                  (((TCALC)(p_f3_ycmb.y) * max_llint_accumulation) +
                                   (TCALC)(p_f3_ycmb.x)),
                                  (((TCALC)(p_f3_zcmb.y) * max_llint_accumulation) +
                                   (TCALC)(p_f3_zcmb.x)) };
            const int95_t dvsx = convertSplitFixedPrecision95((p_f2.x * fr_details.x) +
                                                              (p_f3.x * fr_details.y));
            const int95_t vs_x = combineSplitFixedPrecision(dvsx.x, dvsx.y, parent_xloc,
                                                            parent_xloc_ovrf);
            __stwb(&gmem_r.xcrd[vs_atom],      vs_x.x);
            __stwb(&gmem_r.xcrd_ovrf[vs_atom], vs_x.y);
            const int95_t dvsy = convertSplitFixedPrecision95((p_f2.y * fr_details.x) +
                                                              (p_f3.y * fr_details.y));
            const int95_t vs_y = combineSplitFixedPrecision(dvsy.x, dvsy.y, parent_yloc,
                                                            parent_yloc_ovrf);
            __stwb(&gmem_r.ycrd[vs_atom],      vs_y.x);
            __stwb(&gmem_r.ycrd_ovrf[vs_atom], vs_y.y);
            const int95_t dvsz = convertSplitFixedPrecision95((p_f2.z * fr_details.x) +
                                                              (p_f3.z * fr_details.y));
            const int95_t vs_z = combineSplitFixedPrecision(dvsz.x, dvsz.y, parent_zloc,
                                                            parent_zloc_ovrf);
            __stwb(&gmem_r.zcrd[vs_atom],      vs_z.x);
            __stwb(&gmem_r.zcrd_ovrf[vs_atom], vs_z.y);
#endif
          }
          break;
        case VirtualSiteKind::FIXED_3:
          break;
        case VirtualSiteKind::FAD_3:
          break;
        case VirtualSiteKind::OUT_3:
          break;
        case VirtualSiteKind::FIXED_4:
          {
            const int frame3_atom = (tinsr.y & 0x3ff) + EXCL_GMEM_OFFSET;
            const int frame4_atom = ((tinsr.y >> 10) & 0x3ff) + EXCL_GMEM_OFFSET;
            const llint frame3_xloc = __ldca(&gmem_r.xcrd[frame3_atom]);
            const llint frame3_yloc = __ldca(&gmem_r.ycrd[frame3_atom]);
            const llint frame3_zloc = __ldca(&gmem_r.zcrd[frame3_atom]);
            const llint frame4_xloc = __ldca(&gmem_r.xcrd[frame4_atom]);
            const llint frame4_yloc = __ldca(&gmem_r.ycrd[frame4_atom]);
            const llint frame4_zloc = __ldca(&gmem_r.zcrd[frame4_atom]);
#ifdef TCALC_IS_SINGLE
            const TCALC3 p_f2 = { (TCALC)(frame2_xloc - parent_xloc),
                                  (TCALC)(frame2_yloc - parent_yloc),
                                  (TCALC)(frame2_zloc - parent_zloc) };
            const TCALC3 p_f3 = { (TCALC)(frame3_xloc - parent_xloc),
                                  (TCALC)(frame3_yloc - parent_yloc),
                                  (TCALC)(frame3_zloc - parent_zloc) };
            const TCALC3 p_f4 = { (TCALC)(frame4_xloc - parent_xloc),
                                  (TCALC)(frame4_yloc - parent_yloc),
                                  (TCALC)(frame4_zloc - parent_zloc) };
#else
            const int frame3_xloc_ovrf =  __ldca(&gmem_r.xcrd_ovrf[frame3_atom]);
            const int frame3_yloc_ovrf =  __ldca(&gmem_r.ycrd_ovrf[frame3_atom]);
            const int frame3_zloc_ovrf =  __ldca(&gmem_r.zcrd_ovrf[frame3_atom]);
            const int frame4_xloc_ovrf =  __ldca(&gmem_r.xcrd_ovrf[frame4_atom]);
            const int frame4_yloc_ovrf =  __ldca(&gmem_r.ycrd_ovrf[frame4_atom]);
            const int frame4_zloc_ovrf =  __ldca(&gmem_r.zcrd_ovrf[frame4_atom]);
            const int95t p_f2_xcmb = combineSplitFixedPrecision(frame2_xloc, frame2_xloc_ovrf,
                                                                parent_xloc, parent_xloc_ovrf);
            const int95t p_f2_ycmb = combineSplitFixedPrecision(frame2_yloc, frame2_yloc_ovrf,
                                                                parent_yloc, parent_yloc_ovrf);
            const int95t p_f2_zcmb = combineSplitFixedPrecision(frame2_zloc, frame2_zloc_ovrf,
                                                                parent_zloc, parent_zloc_ovrf);
            const TCALC3 p_f2 =
              { (((TCALC)(p_f2_xcmb.y) * max_llint_accumulation) + (TCALC)(p_f2_xcmb.x)),
                (((TCALC)(p_f2_ycmb.y) * max_llint_accumulation) + (TCALC)(p_f2_ycmb.x)),
                (((TCALC)(p_f2_zcmb.y) * max_llint_accumulation) + (TCALC)(p_f2_zcmb.x)) };
            const int95t p_f3_xcmb = combineSplitFixedPrecision(frame3_xloc, frame3_xloc_ovrf,
                                                                parent_xloc, parent_xloc_ovrf);
            const int95t p_f3_ycmb = combineSplitFixedPrecision(frame3_yloc, frame3_yloc_ovrf,
                                                                parent_yloc, parent_yloc_ovrf);
            const int95t p_f3_zcmb = combineSplitFixedPrecision(frame3_zloc, frame3_zloc_ovrf,
                                                                parent_zloc, parent_zloc_ovrf);
            const TCALC3 p_f3 =
              { (((TCALC)(p_f3_xcmb.y) * max_llint_accumulation) + (TCALC)(p_f3_xcmb.x)),
                (((TCALC)(p_f3_ycmb.y) * max_llint_accumulation) + (TCALC)(p_f3_ycmb.x)),
                (((TCALC)(p_f3_zcmb.y) * max_llint_accumulation) + (TCALC)(p_f3_zcmb.x)) };
            const int95_t p_f4_xcmb = combineSplitFixedPrecision(frame4_xloc, frame4_xloc_ovrf,
                                                                 parent_xloc, parent_xloc_ovrf);
            const int95_t p_f4_ycmb = combineSplitFixedPrecision(frame4_yloc, frame4_yloc_ovrf,
                                                                 parent_yloc, parent_yloc_ovrf);
            const int95_t p_f4_zcmb = combineSplitFixedPrecision(frame4_zloc, frame4_zloc_ovrf,
                                                                 parent_zloc, parent_zloc_ovrf);
            const TCALC3 p_f4 =
              { (((TCALC)(p_f4_xcmb.y) * max_llint_accumulation) + (TCALC)(p_f4_xcmb.x)),
                (((TCALC)(p_f4_ycmb.y) * max_llint_accumulation) + (TCALC)(p_f4_ycmb.x)),
                (((TCALC)(p_f4_zcmb.y) * max_llint_accumulation) + (TCALC)(p_f4_zcmb.x)) };
#endif
            const TCALC3 pf3_m_pf2 = { (fr_details.x * p_f3.x) - p_f2.x,
                                       (fr_details.x * p_f3.y) - p_f2.y,
                                       (fr_details.x * p_f3.z) - p_f2.z };
            const TCALC3 pf4_m_pf2 = { (fr_details.y * p_f4.x) - p_f2.x,
                                       (fr_details.y * p_f4.y) - p_f2.y,
                                       (fr_details.y * p_f4.z) - p_f2.z };
            const TCALC3 p_vs = crossProduct(pf3_m_pf2, pf4_m_pf2);
            const TCALC pvs_factor = fr_details.z / SQRT_FUNC((p_vs.x * p_vs.x) +
                                                              (p_vs.y * p_vs.y) +
                                                              (p_vs.z * p_vs.z));
#ifdef TCALC_IS_SINGLE
            __stwb(&gmem_r.xcrd[vs_atom], parent_xloc + (llint)(pvs_factor * p_vs.x));
            __stwb(&gmem_r.ycrd[vs_atom], parent_yloc + (llint)(pvs_factor * p_vs.y));
            __stwb(&gmem_r.zcrd[vs_atom], parent_zloc + (llint)(pvs_factor * p_vs.z));
#else
            const int95_t dvsx = convertSplitFixedPrecision95(pvs_factor * p_vs.x);
            const int95_t vs_x = combineSplitFixedPrecision(dvsx.x, dvsx.y, parent_xloc,
                                                            parent_xloc_ovrf);
            __stwb(&gmem_r.xcrd[vs_atom],      vs_x.x);
            __stwb(&gmem_r.xcrd_ovrf[vs_atom], vs_x.y);
            const int95_t dvsy = convertSplitFixedPrecision95(pvs_factor * p_vs.y);
            const int95_t vs_y = combineSplitFixedPrecision(dvsy.x, dvsy.y, parent_yloc,
                                                            parent_yloc_ovrf);
            __stwb(&gmem_r.ycrd[vs_atom],      vs_y.x);
            __stwb(&gmem_r.ycrd_ovrf[vs_atom], vs_y.y);
            const int95_t dvsz = convertSplitFixedPrecision95(pvs_factor * p_vs.z);
            const int95_t vs_z = combineSplitFixedPrecision(dvsz.x, dvsz.y, parent_zloc,
                                                            parent_zloc_ovrf);
            __stwb(&gmem_r.zcrd[vs_atom],      vs_z.x);
            __stwb(&gmem_r.zcrd_ovrf[vs_atom], vs_z.y);            
#endif
          }
          break;
        }
      }
    }
    
#ifdef VSITE_STANDALONE
  }
}
#endif

#undef EXCL_GMEM_OFFSET
